package com.dharmikharkhani.notes.service;

import com.dharmikharkhani.notes.auth.model.User;
import com.dharmikharkhani.notes.auth.repository.UserRepository;
import com.dharmikharkhani.notes.entity.Note;
import com.dharmikharkhani.notes.entity.Tag;
import com.dharmikharkhani.notes.repository.NoteRepository;
import com.dharmikharkhani.notes.repository.TagRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.Set;

@Service
public class DemoAccountService {

    private static final Logger logger = LoggerFactory.getLogger(DemoAccountService.class);

    private final UserRepository userRepository;
    private final NoteRepository noteRepository;
    private final TagRepository tagRepository;
    private final BCryptPasswordEncoder passwordEncoder;

    public DemoAccountService(UserRepository userRepository, NoteRepository noteRepository,
                              TagRepository tagRepository, BCryptPasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.noteRepository = noteRepository;
        this.tagRepository = tagRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Transactional
    public User createDemoAccount(String name, String email, String password, String personaType) {
        // Check if demo account already exists
        if (userRepository.findByEmail(email).isPresent()) {
            logger.info("Demo account already exists: {}", email);
            return userRepository.findByEmail(email).get();
        }

        logger.info("Creating demo account: {} ({})", name, email);

        // Create demo user
        User demoUser = new User();
        demoUser.setName(name);
        demoUser.setEmail(email);
        demoUser.setPassword(passwordEncoder.encode(password));
        demoUser.setRoles("ROLE_user");
        demoUser.setProvider("JWT");
        demoUser.setEmailVerified(true);
        demoUser.setAccountApproved(true); // Auto-approved
        demoUser.setAccountRejected(false);
        demoUser.setIsDemoAccount(true); // Mark as demo account
        demoUser.setLastActivityAt(null); // No activity yet

        User savedUser = userRepository.save(demoUser);

        // Create demo notes based on persona
        createDemoNotes(savedUser, personaType);

        logger.info("Demo account created successfully: {}", email);
        return savedUser;
    }

    @Transactional
    public void resetDemoAccount(User user) {
        logger.info("Resetting demo account: {}", user.getEmail());

        // Delete all notes owned by the demo user
        noteRepository.deleteByOwner(user);

        // Recreate demo notes based on email (extract persona type)
        String personaType = extractPersonaType(user.getEmail());
        createDemoNotes(user, personaType);

        // Reset activity timestamp
        user.setLastActivityAt(null);
        userRepository.save(user);

        logger.info("Demo account reset complete: {}", user.getEmail());
    }

    @Transactional
    public void shareNotesBetweenDemoAccounts() {
        logger.info("Setting up note sharing between demo accounts...");

        User pm = userRepository.findByEmail("demo-pm@notesapp.com").orElse(null);
        User dev = userRepository.findByEmail("demo-dev@notesapp.com").orElse(null);
        User designer = userRepository.findByEmail("demo-design@notesapp.com").orElse(null);
        User writer = userRepository.findByEmail("demo-writer@notesapp.com").orElse(null);
        User student = userRepository.findByEmail("demo-student@notesapp.com").orElse(null);

        if (pm == null || dev == null || designer == null || writer == null || student == null) {
            logger.warn("Not all demo accounts found, skipping note sharing");
            return;
        }

        // Share PM's roadmap with Dev and Designer
        shareNoteByTitle(pm, "Q1 2025 Product Roadmap", dev, designer);

        // Share PM's sprint planning with Dev
        shareNoteByTitle(pm, "Sprint Planning Notes", dev);

        // Share Dev's API docs with PM
        shareNoteByTitle(dev, "API Documentation - Authentication", pm);

        // Share Dev's bug tracker with PM and Designer
        shareNoteByTitle(dev, "Bug Tracker - WebSocket Issues", pm, designer);

        // Share Designer's mockups with PM and Dev
        shareNoteByTitle(designer, "UI Mockups - Mobile Dashboard", pm, dev);

        // Share Designer's design system with Dev and Writer
        shareNoteByTitle(designer, "Design System - Color Palette", dev, writer);

        // Share Writer's blog draft with PM and Designer
        shareNoteByTitle(writer, "Blog Post Draft: Getting Started with Notes", pm, designer);

        // Share Student's project ideas with Dev
        shareNoteByTitle(student, "Project Ideas - Spring Semester", dev);

        logger.info("Note sharing setup complete");
    }

    private void shareNoteByTitle(User owner, String title, User... usersToShareWith) {
        noteRepository.findByOwner(owner).stream()
            .filter(note -> note.getTitle().equals(title))
            .findFirst()
            .ifPresent(note -> {
                Set<User> sharedWith = note.getSharedWith();
                if (sharedWith == null) {
                    sharedWith = new HashSet<>();
                }
                for (User user : usersToShareWith) {
                    sharedWith.add(user);
                }
                note.setSharedWith(sharedWith);

                // Add collaboration banner to the note content
                String[] collaboratorNames = new String[usersToShareWith.length];
                for (int i = 0; i < usersToShareWith.length; i++) {
                    collaboratorNames[i] = usersToShareWith[i].getName();
                }
                String banner = createCollaborationBanner(collaboratorNames);

                // Prepend banner to existing content if not already present
                String currentContent = note.getContent();
                if (!currentContent.contains("Live Collaboration Active")) {
                    note.setContent(banner + currentContent);
                }

                noteRepository.save(note);
                logger.debug("Shared note '{}' from {} with {} users", title, owner.getEmail(), usersToShareWith.length);
            });
    }

    private String extractPersonaType(String email) {
        if (email.contains("pm")) return "product-manager";
        if (email.contains("dev")) return "developer";
        if (email.contains("design")) return "designer";
        if (email.contains("writer")) return "writer";
        if (email.contains("student")) return "student";
        return "product-manager"; // default
    }

    @Transactional
    public void createDemoNotes(User user, String personaType) {
        switch (personaType) {
            case "product-manager":
                createProductManagerNotes(user);
                break;
            case "developer":
                createDeveloperNotes(user);
                break;
            case "designer":
                createDesignerNotes(user);
                break;
            case "writer":
                createWriterNotes(user);
                break;
            case "student":
                createStudentNotes(user);
                break;
            default:
                createProductManagerNotes(user);
        }
    }

    private void createProductManagerNotes(User user) {
        createNote(user, "Q1 2025 Product Roadmap",
                "<p><strong><u>Q1 2025 Product Roadmap - Strategic Vision and Execution Plan</u></strong></p>" +
                "<p><em>Last updated: December 20, 2024 by Alex Smith, Product Manager</em></p>" +
                "<p>This quarter represents a critical inflection point for NotesApp as we transition from being a single-user productivity tool into a full-fledged collaborative workspace platform. After conducting extensive user research over the past six weeks, we've discovered that seventy-eight percent of our power users are actively requesting team collaboration features. The market timing couldn't be better - our competitors are either too complex or lack real-time capabilities, giving us a unique window of opportunity to capture significant market share in the collaborative note-taking space.</p>" +
                "<p>Our vision for Q1 is clear and ambitious. We need to establish ourselves as the market leader in real-time collaboration while simultaneously expanding our mobile user base and achieving our first profitability milestone. Currently, only twelve percent of our users access NotesApp via mobile devices, which represents a massive untapped opportunity. By the end of March, we aim to break even on operational costs while tripling our mobile user base.</p>" +
                "<p><strong>Primary Strategic Objectives for the Quarter</strong></p>" +
                "<p>The first major objective is to establish market leadership in real-time collaboration. We're competing directly with established players like Notion and Google Docs, but our advantage lies in simplicity and speed. While Notion has become bloated with features that most users never touch, we're focusing on doing one thing exceptionally well - collaborative note-taking. Our Operational Transformation technology is already ninety percent complete, and early beta testing shows it's faster and more reliable than what competitors offer.</p>" +
                "<p>Our second objective centers on mobile expansion. The mobile app market for productivity tools is expected to grow by forty-five percent this year, and we're currently underrepresented in this space. We've allocated significant resources to building native iOS and Android apps using React Native, which will allow us to maintain code sharing while delivering native performance. The apps are already thirty percent complete on iOS and fifteen percent on Android.</p>" +
                "<p>The third objective is reaching profitability. We've been operating at a loss for the past eighteen months, burning through our seed funding. The board of directors has made it clear that we need to demonstrate a path to profitability by end of Q1. This means we need to increase our premium conversion rate from two point one percent to at least four point five percent, while also increasing our average revenue per user from one dollar eighty to three dollars fifty.</p>" +
                "<p><strong>Feature Development Priorities and Timeline</strong></p>" +
                "<p>Real-time collaboration is our <u>P0 critical path feature</u>. We're currently eighty-five percent complete with this initiative. The WebSocket infrastructure is fully operational and has been tested with up to one hundred concurrent users without any performance degradation. Our Operational Transformation algorithm is working flawlessly in development, handling complex scenarios like simultaneous edits to the same paragraph. The cursor position synchronization is currently in QA testing, and we expect it to be production-ready by January tenth.</p>" +
                "<p>The biggest remaining challenge is the conflict resolution UI. When two users edit the exact same word simultaneously, we need to show them what happened in a way that's intuitive and doesn't interrupt their flow. We've designed three different approaches and will be conducting user testing next week to determine which one resonates best. Our target launch date for the collaboration MVP is January fifteenth, giving us two weeks of buffer before the end of the month.</p>" +
                "<p>Success for the collaboration feature means that twenty-five percent of all active notes become collaborative within thirty days of launch. We'll track this metric daily and adjust our go-to-market strategy based on adoption patterns. Early indicators from beta testing suggest we'll exceed this target - beta users are collaborating on forty percent of their notes.</p>" +
                "<p>The mobile app beta launch is our second P0 priority. Development officially kicks off on January twentieth, immediately after the collaboration feature launches. We're building both iOS and Android apps simultaneously, with a target of feature parity with the web application. This includes the ability to view notes, edit notes, sync in real-time, and work offline with conflict resolution when connectivity returns.</p>" +
                "<p>Offline mode is particularly critical for mobile users. Our research shows that sixty-seven percent of mobile users access notes while commuting on subways or in areas with poor connectivity. We're implementing a local-first architecture where all changes are saved locally first, then synced to the server when connection is available. This requires significant engineering work but is non-negotiable for a quality mobile experience.</p>" +
                "<p>The beta launch is scheduled for March first on TestFlight for iOS and Google Play beta for Android. We'll invite our one hundred most active users plus anyone on the beta waitlist, which currently has three hundred seventy-two signups. The public launch is set for March fifteenth. Success metrics include five thousand downloads in the first month and maintaining a four point two star rating or higher in app stores.</p>" +
                "<p><strong>High-Value Secondary Features</strong></p>" +
                "<p>Note templates represent a significant revenue opportunity and user experience improvement. Based on customer interviews, the most requested templates are for meeting notes, product requirement documents, retrospectives, and one-on-one conversations. We're building a system that allows users to create their own templates with version control, plus a community marketplace where users can share templates.</p>" +
                "<p>The marketplace has interesting monetization potential. We're planning to offer both free community templates and premium templates priced between five and fifteen dollars. Power users have indicated willingness to pay for high-quality templates that save them time. For example, a comprehensive PRD template that includes all the sections and prompts could easily command ten dollars from product managers who write multiple PRDs per month.</p>" +
                "<p>Advanced search with semantic discovery is another high-value feature. Currently, users can only search for exact text matches, which becomes frustrating as their note library grows. We're implementing AI-powered semantic search that understands intent. For example, searching for \"Q4 marketing\" would find notes about \"fourth quarter promotional campaigns\" even if those exact words don't appear.</p>" +
                "<p>This feature leverages OpenAI's embedding API to convert notes into vector representations, then uses similarity search to find relevant content. The technical implementation is straightforward, but we need to be mindful of API costs. At scale, we estimate this will add approximately twelve cents per user per month in OpenAI costs, which we can easily absorb given our premium pricing.</p>" +
                "<p><strong>Success Metrics and Key Performance Indicators</strong></p>" +
                "<p>We're tracking six primary metrics throughout the quarter. Monthly Active Users is our north star metric. We're currently at three thousand two hundred MAU and targeting ten thousand by end of March, with a stretch goal of fifteen thousand. This requires an average growth rate of thirty-five percent month-over-month, which is aggressive but achievable based on historical growth patterns.</p>" +
                "<p>Collaboration adoption rate is critical for validating our product direction. We're targeting forty percent of users creating at least one collaborative note within their first thirty days, with a stretch goal of fifty-five percent. Early beta testing suggests this is realistic - collaboration is naturally viral, as one user inviting collaborators brings new users into the platform.</p>" +
                "<p>Premium conversion rate needs to increase from two point one percent to four point five percent. We're implementing several strategies to drive this, including limiting collaborative notes to two on the free plan, adding a paywall for templates after users create five free templates, and introducing a fourteen-day trial of premium features for all new users. Historical data shows that users who experience premium features during a trial convert at nine percent versus two percent for those who don't.</p>" +
                "<p>Average revenue per user is calculated across all users, including free tier. We need to increase this from one dollar eighty to three dollars fifty. This comes from a combination of higher conversion rates and introducing new revenue streams like premium templates and add-ons. We're also testing a new Team plan at fifteen dollars per user per month for companies, which early sales calls suggest will have strong demand.</p>" +
                "<p>Net Promoter Score is our quality and satisfaction metric. We're currently at forty-two, which is decent but not great. Our target is fifty-five, with a stretch goal of sixty-five. To improve NPS, we're focusing on reliability, reducing bugs, improving performance, and adding the features users are requesting. Every month we survey a random sample of users and track NPS trends.</p>" +
                "<p><strong>Risk Analysis and Mitigation Strategies</strong></p>" +
                "<p>The biggest technical risk is WebSocket infrastructure scalability. We've successfully tested with one hundred concurrent users in development, but production will eventually require supporting ten thousand plus simultaneous connections. We don't have in-house expertise in operating WebSocket infrastructure at scale, which is why we're partnering with AWS to leverage their managed services and auto-scaling capabilities. This adds approximately five thousand dollars per month to our infrastructure costs but significantly reduces operational risk.</p>" +
                "<p>Market risk is also significant. If Notion announces major real-time collaboration improvements during Q1, it could undermine our differentiation strategy. Our mitigation is to emphasize simplicity and speed over feature count. Notion has become bloated - their interface is overwhelming for new users and the learning curve is steep. We're positioning as the anti-Notion: simple, fast, focused. User research validates this positioning strongly.</p>" +
                "<p>Resource risk is very real. Our mobile team consists of only two developers, both of whom are contractors. If either leaves during the quarter, it would jeopardize our mobile launch timeline. We're mitigating this by hiring a third iOS developer in January and building comprehensive documentation so knowledge isn't trapped in anyone's head. We're also paying our contractors above market rate and treating them as core team members to maximize retention.</p>" +
                "<p>Regulatory risk around GDPR compliance for European users could delay our international expansion. We have a legal review scheduled for January tenth to audit our data handling practices and ensure compliance. Early assessment suggests we're ninety percent compliant already, with minor adjustments needed around data portability and deletion workflows.</p>" +
                "<p><strong>Budget Allocation and Resource Planning</strong></p>" +
                "<p>Our total Q1 budget is two hundred seventy-five thousand dollars, allocated across four categories. Engineering represents the largest portion at one hundred eighty thousand dollars, covering three full-time employees plus two contractors. This is our core investment and non-negotiable. Infrastructure costs including AWS, SendGrid for emails, and various SaaS tools total twenty-five thousand dollars for the quarter.</p>" +
                "<p>Marketing budget is forty thousand dollars, with the majority allocated to app store advertising once mobile apps launch. We're also investing in content marketing, including blog posts, case studies, and social media presence. The marketing team is currently one person, so most of the budget goes to paid channels and contractor content creators.</p>" +
                "<p>Design investment is thirty thousand dollars for one contractor focused specifically on mobile UI design. Mobile design is fundamentally different from web, and we need someone who deeply understands iOS and Android design patterns to make our apps feel native rather than like web wrappers.</p>" +
                "<p><strong>Key Milestones and Review Cadence</strong></p>" +
                "<p>January fifteenth is our collaboration MVP launch. This includes a coordinated press release, blog post, email to all users, and social media campaign. We'll be monitoring usage metrics hourly for the first seventy-two hours to catch any issues early. February first is our mid-quarter roadmap review with key stakeholders including the CEO, CTO, and board advisor. This is where we'll assess whether we're on track or need to make adjustments.</p>" +
                "<p>February fifteenth marks the templates library beta launch. We're starting with ten high-quality templates created by our team, then opening up community submissions in late February. March first is the mobile app beta launch on TestFlight and Google Play, targeting our most engaged users first. March fifteenth is the public mobile app launch, which will be our biggest product announcement of the year.</p>" +
                "<p>March thirty-first is the end of quarter retrospective and Q2 planning kickoff. We'll analyze what worked, what didn't, and incorporate those learnings into Q2 planning. The goal is to celebrate wins while being brutally honest about shortcomings so we can continuously improve our execution.</p>" +
                "<p><em>Next review scheduled for Monday, December 23rd at 10am PT with engineering leads Jamie and Morgan to align on technical dependencies and sprint planning.</em></p>",
                "roadmap", "planning", "Q1-2025");

        createNote(user, "User Feedback Sprint 12",
                "<p><strong><u>Sprint 12 User Research Summary - Key Insights and Action Items</u></strong></p>" +
                "<p><em>Research conducted: December 1-14, 2024 | Participants: 24 users across various segments</em></p>" +
                "<p>We just completed our most comprehensive user research sprint to date, interviewing twenty-four users across different segments including power users, free tier users, team administrators, and recent sign-ups. The insights we gained are both validating and challenging, confirming some of our assumptions while revealing critical gaps in our product that we need to address urgently.</p>" +
                "<p><strong>Overwhelmingly Positive Feedback on Core Experience</strong></p>" +
                "<p>The good news is that users absolutely love what we've built so far. Ninety-two percent of interviewees praised our clean, distraction-free interface. One user, a freelance writer named Maria, told us that she switched from Evernote specifically because NotesApp doesn't have the overwhelming sidebar with dozens of features she never uses. She described our interface as refreshing and calming, which helps her focus on writing rather than fighting with software.</p>" +
                "<p>The rich text editor received particularly strong praise. Users find it intuitive and powerful without feeling bloated. The keyboard shortcuts work exactly as they expect, and the formatting bar appears when they need it but stays out of the way otherwise. Several users who came from Google Docs mentioned that our editor feels faster and more responsive, especially when working with longer documents.</p>" +
                "<p>Tag-based organization is resonating strongly with our target users. Unlike folder hierarchies which force you to choose one location for each note, tags allow flexible, multi-dimensional organization. Power users have developed sophisticated tagging systems - one product manager showed us how he uses context tags like work, personal, and urgent combined with project tags to create dynamic views of his notes. He mentioned that this system has completely changed how he manages information.</p>" +
                "<p>Performance and reliability are major strengths according to user feedback. Notes save instantly, search is lightning fast even for users with hundreds of notes, and the application has never crashed for any of our interviewees. In the productivity software space where bugs and slowness are common complaints, our stability is a significant competitive advantage.</p>" +
                "<p><strong>Critical Pain Points That Need Immediate Attention</strong></p>" +
                "<p>The mobile app situation is our biggest problem by far. Eighty percent of users specifically mentioned the lack of a mobile app as their number one frustration with NotesApp. The current mobile web experience is functional but far from ideal - the interface doesn't adapt well to small screens, typing on mobile keyboards is awkward, and there's no offline access which is critical for mobile use cases.</p>" +
                "<p>Users described numerous scenarios where they desperately need mobile access. Commuters want to capture ideas on the subway where internet is spotty. Professionals need to reference notes during client meetings. Students want to review study guides between classes. Right now, they're either carrying laptops everywhere or using other apps for mobile, which creates friction and reduces engagement with NotesApp.</p>" +
                "<p>One particularly insightful interview was with David, a sales consultant who travels constantly. He said he starts notes in NotesApp at his desk but then has to email them to himself or copy them to Apple Notes when he's on the go. This workflow is clunky and means NotesApp isn't his single source of truth, which reduces its value significantly. When we asked if he'd pay more for a good mobile app, he said he'd upgrade to Pro immediately.</p>" +
                "<p>Offline mode is the second most requested feature, mentioned by fifty-seven percent of users. Even users with reliable internet want the peace of mind that their notes are always accessible. Trust is a major factor - several users mentioned anxiety about cloud-only services becoming unavailable when they need them most. Offering offline access with intelligent syncing when connectivity returns would address both practical needs and emotional concerns about reliability.</p>" +
                "<p>Note templates emerged as an unexpected but consistent request, brought up by forty-three percent of users without any prompting from us. Users are creating the same types of notes repeatedly - weekly meeting notes with the same agenda structure, project kick-off documents with standard sections, daily journals with consistent prompts. They're currently copy-pasting old notes and manually updating them, which is tedious and error-prone.</p>" +
                "<p>The template request gets interesting when you dig into specifics. Different user segments want different templates. Product managers want templates for PRDs, sprint planning, and user story mapping. Engineers want templates for incident reports, technical design documents, and code review notes. Writers want templates for article outlines, character profiles, and editorial calendars. This suggests we could build a template marketplace where users share and even sell specialized templates.</p>" +
                "<p><strong>Collaboration Features - Mixed Signals</strong></p>" +
                "<p>Real-time collaboration generated interesting responses. Thirty-eight percent of users said they desperately need it and would use it daily. These tend to be users who work in teams - product managers collaborating with engineers, students working on group projects, families planning events together. For them, collaboration isn't a nice-to-have, it's essential for NotesApp to be their primary tool.</p>" +
                "<p>However, forty-one percent of users said they rarely or never would use collaboration features. These are mostly individual users - writers, researchers, personal journaling users. For them, NotesApp is a private thinking space, and they have no interest in inviting others into their notes. This split is important for our product strategy - we need to add collaboration without compromising the simplicity that solo users love.</p>" +
                "<p>The remaining twenty-one percent weren't sure, saying they might use collaboration occasionally but it's not critical. These users represent an opportunity - if we implement collaboration really well, they might discover use cases they hadn't considered. For example, one user said she never thought about collaborative notes but realized during the interview that it would be perfect for planning her wedding with her fianc.</p>" +
                "<p><strong>Pricing and Willingness to Pay</strong></p>" +
                "<p>We asked users about pricing sensitivity and upgrade triggers. Current free tier users overwhelmingly said the limit of one hundred notes is generous and sufficient for their current needs, but many anticipate outgrowing it within six to twelve months. The two collaborator limit on free tier is actually more restrictive than the note limit for team users - several mentioned they'd upgrade specifically to add more collaborators once we launch that feature.</p>" +
                "<p>Premium pricing at nine dollars per month was described as very reasonable by most users, especially compared to competitors. Notion charges ten dollars, Evernote charges eight dollars, and neither offers our level of simplicity and speed. Users see the value proposition clearly. However, several users mentioned they wish we offered annual billing with a discount - they'd prepay for a year at seventy-five to eighty dollars to save money and avoid monthly charges.</p>" +
                "<p>The team plan at fifteen dollars per user per month generated mixed reactions. Some team administrators thought it was quite affordable compared to other business software. Others felt it was steep for small teams of three to five people, suggesting we might need a small team plan with different pricing. One interesting suggestion was to charge per team rather than per user for teams under ten people, which would make the math easier and more predictable.</p>" +
                "<p><strong>Feature Requests We're Not Doing</strong></p>" +
                "<p>Several users asked for features that we're intentionally not building. Database functionality like Notion's tables was mentioned by eleven users, but we're staying focused on note-taking rather than becoming a database tool. Calendar integration was requested by eight users, but we believe this adds complexity that dilutes our core value. AI writing assistance came up six times, but the technology isn't reliable enough yet and we don't want to compete on AI features.</p>" +
                "<p>It's important to say no to feature requests that don't align with our vision. Every feature adds code to maintain, UI complexity, and cognitive load for users. Our strength is simplicity, and we need to protect that ruthlessly even when saying no disappoints some users. The users who want databases should use Notion. The users who want AI should use other tools. We're building the best note-taking experience, period.</p>" +
                "<p><strong>Clear Action Items from This Research</strong></p>" +
                "<p>Based on this research, we're making several strategic decisions. First, mobile app development becomes our highest priority after launching real-time collaboration. We can't afford to wait any longer - eighty percent user demand is overwhelming and competitors all have mobile apps. We're allocating our full mobile team to this starting in January and hiring an additional iOS developer to accelerate development.</p>" +
                "<p>Second, offline mode is non-negotiable for both mobile and web applications. We're implementing a local-first architecture where all data is stored locally first, synced to the cloud second. This addresses both the technical need for offline access and the emotional need for reliability and trust. Engineering estimates this adds four weeks to mobile development, but it's worth it.</p>" +
                "<p>Third, we're building a template system with both personal and community templates. Users can create templates for their own repeated use, and we'll build a marketplace where users can share templates publicly. We'll start with free templates only, then explore premium templates as a revenue stream once the marketplace has sufficient inventory and usage.</p>" +
                "<p>Fourth, collaboration features will be designed with an explicit toggle so users who don't want collaboration never see those features cluttering their interface. We're adding a setting called workspace mode with two options: personal and team. Personal mode hides all collaboration UI, keeping NotesApp simple for solo users. Team mode reveals sharing, comments, and presence features. This way we serve both segments without compromise.</p>" +
                "<p><em>Next steps: Share these findings with the full team in Monday's all-hands meeting. Schedule follow-up interviews with the six users who expressed interest in beta testing collaboration features. Begin recruiting for mobile user testing planned for February.</em></p>",
                "user-research", "feedback", "sprint");

        createNote(user, "Feature Spec: Note Templates",
                "<p><strong><u>Feature Specification - Note Templates System</u></strong></p>" +
                "<p><em>Version 1.0 - Created December 15, 2024 by Alex Smith, Product Manager</em></p>" +
                "<p><em>Status: Approved for Q1 2025 Development - Priority: High</em></p>" +
                "<p>The Note Templates feature represents one of the most requested capabilities from our user base, with forty-three percent of users spontaneously mentioning it during our recent research sprint. This feature will enable users to create, save, and reuse structured note formats for recurring scenarios, dramatically reducing the time required to create new notes while ensuring consistency across similar documents. Templates address a fundamental friction point in the current user experience where users repeatedly copy old notes and manually clear the content, a workaround that is both tedious and error-prone.</p>" +
                "<p>Our research has revealed that different user segments create remarkably similar note structures repeatedly. Product managers write product requirement documents with the same sections every time. Engineers create incident reports following standard formats. Students take lecture notes with consistent layouts. Writers outline articles using familiar structures. By formalizing these patterns into reusable templates, we can save users significant time while improving the quality and consistency of their notes. Early user testing suggests templates could reduce note creation time by thirty to forty percent for structured documents.</p>" +
                "<p><strong>Primary User Stories and Use Cases</strong></p>" +
                "<p>The core user story is straightforward: as a user, I want to create a template from any existing note so I can reuse that structure for similar notes in the future. When a user identifies a note structure they use frequently, they should be able to save it as a template with a single click. The template captures the note's structure including headings, placeholder text, and formatting, but not the specific content. When creating a new note from a template, users get a fresh copy pre-populated with the structure they need.</p>" +
                "<p>The second critical user story focuses on discovery: as a user, I want to browse and use templates created by the community so I can benefit from best practices without starting from scratch. Many users, especially new ones, don't know what structure works best for different types of notes. A community template library allows experienced users to share their proven formats. For example, a seasoned product manager could share their comprehensive PRD template that includes all the sections developed through years of experience. A new PM could use that template immediately rather than figuring out the structure themselves.</p>" +
                "<p>Template customization is the third key user story: as a user, I want to modify existing templates to fit my specific needs so I can adapt community templates to my workflow. Not every template will perfectly match every user's requirements. Some users might want to add sections, remove unnecessary parts, or adjust the formatting. Templates should be easily customizable, with changes either saved as a new template or as modifications to a personal copy of a community template. This flexibility ensures templates remain useful even as user needs evolve.</p>" +
                "<p>Organization and management of templates is another important use case: as a user with many templates, I want to categorize and search my templates so I can quickly find the right template when creating a note. Power users might accumulate dozens of templates over time. Without organization, finding the right template becomes as time-consuming as creating the note manually. We need to support template categories, tags, and search functionality to ensure templates remain discoverable even as the library grows.</p>" +
                "<p><strong>Technical Architecture and Implementation Requirements</strong></p>" +
                "<p>The backend implementation requires extending our existing data model with a new Template entity. Templates share many characteristics with Notes - they have titles, content, tags, owners, and timestamps. However, templates also need unique attributes like a public or private visibility flag, a usage count to track popularity, a category classification, and potentially a version number if we support template updates. The Template entity should reference the User entity as the creator and support a many-to-many relationship with Tags for categorization.</p>" +
                "<p>Template CRUD operations need comprehensive API endpoints. Creating a template can happen two ways: from scratch using a template creation interface, or by converting an existing note into a template. The conversion process needs to intelligently identify what should become placeholder text versus what should be removed. For example, specific dates should become placeholders like insert date here, while actual content should be cleared. Reading templates requires endpoints for listing personal templates, browsing community templates with pagination and filtering, and retrieving a specific template for instantiation.</p>" +
                "<p>Updating templates introduces interesting versioning questions. If a user updates a template they created and shared publicly, should existing notes created from that template be affected? Our current thinking is no - templates create independent copies, so updating a template only affects future uses. However, we should track template versions and potentially notify users when a template they've used has been updated, allowing them to optionally apply changes. This gives users control while keeping them informed of improvements. Deleting templates should be straightforward for personal templates, but community templates with high usage should perhaps be archived rather than deleted to avoid breaking references.</p>" +
                "<p>The template instantiation process is critical to the user experience. When a user creates a note from a template, we need to create a new Note entity with a deep copy of the template content, replacing any placeholders with empty fields or prompts. The new note should inherit suggested tags from the template but allow the user to modify them. The instantiation should be fast - users shouldn't notice any delay compared to creating a blank note. On the frontend, template instantiation should happen immediately with the note editor opening in a pre-populated state.</p>" +
                "<p><strong>Community Template Marketplace and Discovery</strong></p>" +
                "<p>The community marketplace represents a significant differentiator for NotesApp. While competitors like Notion offer templates, the discovery experience is often poor and templates are scattered across various websites and forums. We have an opportunity to build the best template marketplace in the category by focusing on curation, quality, and discoverability. The marketplace should feel more like an app store than a file repository - polished, professional, and trustworthy.</p>" +
                "<p>Template submission and curation requires careful process design. We'll start with an open submission model where any user can publish templates to the community. However, we need quality controls to prevent spam and low-effort submissions. Initial quality controls will be automated - templates must have a title, description, at least fifty characters of content, and appropriate tags. After launch, we can introduce human curation where our team or trusted community members review and feature high-quality templates.</p>" +
                "<p>Template categories help users navigate the marketplace efficiently. Based on our user research, we've identified initial categories including Meeting Notes, Project Planning, Product Management, Engineering, Design, Writing, Education, Personal, and Miscellaneous. Each category can have subcategories - for example, Product Management includes PRDs, User Stories, Sprint Planning, and Retrospectives. Categories should be extensible as we identify new use cases, but we should resist category proliferation that makes browsing overwhelming.</p>" +
                "<p>Search and filtering capabilities are essential for marketplace usability. Users should be able to search by keyword, filter by category, sort by popularity or recency, and view featured templates curated by our team. Advanced filters could include filtering by creator if users find someone whose templates they consistently like, or filtering by tag combinations for very specific use cases. The search should be fast and results should include preview snippets showing template structure to help users evaluate relevance before opening.</p>" +
                "<p>Template preview and rating systems help users evaluate quality before committing. When browsing templates, users should see a preview showing the template structure without having to instantiate it. This preview could be a read-only view of the template content or a simplified outline showing major sections. After using a template, users should be able to rate it on a five-star scale and optionally leave a brief review. High-rated templates get promoted in search results and featured sections, creating a quality feedback loop.</p>" +
                "<p><strong>Monetization Opportunities and Business Model</strong></p>" +
                "<p>Templates present interesting monetization possibilities beyond our core subscription model. The most straightforward approach is premium templates sold individually or as bundles. Professional-grade templates for specialized use cases could command prices from five to twenty-five dollars. For example, a comprehensive project management template bundle including PRDs, sprint planning templates, retrospective formats, and status report templates could sell for twenty dollars. Users who create valuable templates could earn revenue sharing, incentivizing quality contributions.</p>" +
                "<p>Template marketplace transactions require payment infrastructure we don't currently have. We'd need to integrate with a payment processor like Stripe, handle tax calculations and remittance, manage payouts to template creators, and provide purchase history and refunds. This is significant engineering work but could create a new revenue stream while building a creator economy around NotesApp. We estimate marketplace monetization could add ten to fifteen percent to our revenue within a year if executed well.</p>" +
                "<p>An alternative monetization approach is keeping all templates free but using them as a premium tier feature. Free tier users could use up to three templates total, while premium users get unlimited template usage and creation. This drives premium conversions by showcasing advanced productivity features that free users can taste but must upgrade to fully utilize. User research suggests twenty-three percent of free tier users would consider upgrading specifically for unlimited templates, making this a viable conversion driver.</p>" +
                "<p><strong>Success Metrics and Performance Indicators</strong></p>" +
                "<p>We'll measure template feature success through multiple metrics tracked weekly. The primary adoption metric is percentage of active users who create or use at least one template within thirty days of feature launch. Our target is fifty percent adoption, with a stretch goal of seventy percent. Early beta testing with fifteen users showed eighty-seven percent created templates within the first week, suggesting strong organic demand. We'll segment this metric by user type to understand which personas find templates most valuable.</p>" +
                "<p>Template usage frequency indicates ongoing value beyond initial novelty. We're targeting an average of three template uses per active template user per week. If users create templates but rarely use them, the feature isn't delivering sustained value. Conversely, if power users are creating notes from templates five to ten times per week, we know templates have become integral to their workflow. This metric will help us understand if we need to improve template discoverability or ease of use.</p>" +
                "<p>Community marketplace engagement measures the social and sharing aspects. We're targeting five hundred community templates published within three months of launch, with one hundred creators contributing. Marketplace templates should account for at least thirty percent of all template uses, showing that community templates add value beyond personal templates. Template ratings and reviews provide qualitative feedback on what works well and what doesn't, guiding future improvements.</p>" +
                "<p>Time to create note is our efficiency metric. Currently, users spend an average of forty-five seconds setting up structure when creating a note for a familiar format. With templates, we're targeting a reduction to fifteen seconds - a thirty-second or sixty-seven percent improvement. We'll measure this through client-side analytics tracking time from clicking new note to starting actual content entry. If we hit this target, templates deliver clear productivity value that justifies the development investment.</p>" +
                "<p>Premium conversion impact measures business value. We hypothesize that users who actively use templates convert to premium at a higher rate than users who don't. We'll track conversion rates for template users versus non-users, with a hypothesis that template users convert at one point five to two times the baseline rate. If this holds true, templates justify investment through improved monetization even before considering direct template sales.</p>" +
                "<p><strong>User Interface and Experience Design</strong></p>" +
                "<p>Template creation should be effortless and discoverable. When editing any note, users should see a clearly visible button labeled Save as Template in the note options menu. Clicking this opens a simple modal asking for template name, optional description, category selection, and whether to make it public or keep it private. The modal should show a preview of what the template will look like with placeholder text highlighted. After confirmation, the template is saved and the user receives feedback that they can now use this template when creating notes.</p>" +
                "<p>Template usage should be integrated into the new note flow. Currently, clicking New Note creates a blank note immediately. With templates, clicking New Note should show a choice: Blank Note or From Template. Selecting From Template opens a template picker showing personal templates first, then community templates. Templates are displayed as cards showing template name, creator, category tag, and a brief preview. Clicking a template creates a new note from that template instantly. The entire flow should take no more than three clicks and two seconds.</p>" +
                "<p>Template management needs a dedicated interface accessible from settings or a templates menu item. This interface shows all personal templates in a grid or list view with search and filtering. Users can preview, edit, delete, or update sharing settings for their templates. Usage statistics show how many notes each user has created from each template, helping users identify their most valuable templates. For community templates the user has bookmarked or used, there's a separate section showing those templates with options to unfavorite or check for updates.</p>" +
                "<p><strong>Development Timeline and Resource Allocation</strong></p>" +
                "<p>We're scheduling template development for February 2025, immediately after the collaboration feature launches in January. The implementation will follow a phased approach starting with an MVP and expanding to full marketplace functionality. Sprint fourteen in early February will focus on backend infrastructure including the Template entity, database migrations, and API endpoints. Sprint fifteen in mid-February will build the frontend template creation and usage flows. Sprint sixteen in late February will implement the community marketplace with search, filtering, and rating systems.</p>" +
                "<p>Engineering resource requirements include one full-stack engineer dedicated full-time for six weeks, plus part-time support from our senior backend engineer for database schema design and one designer for UI/UX work. The frontend engineer will build the template picker, creation modal, and management interface using our existing React component library, minimizing new design work. The backend engineer will implement the new API endpoints, integrate with our existing tag and user systems, and ensure templates work correctly with our authorization model.</p>" +
                "<p>Quality assurance and testing will be extensive given the feature's complexity. We need to test template creation from various note formats, ensure template instantiation works correctly with different content types, verify marketplace search performs well with thousands of templates, and confirm privacy settings work correctly for public versus private templates. Beta testing with twenty users will run for two weeks before public launch, giving us time to identify and fix issues before rolling out to all users.</p>" +
                "<p><strong>Risks and Mitigation Strategies</strong></p>" +
                "<p>The biggest risk is feature scope creep. Templates could expand endlessly with features like template variables, conditional content, template inheritance, and advanced formatting options. We must be disciplined about shipping a simple, useful MVP first and adding complexity only based on user feedback. Our mitigation is a strict feature freeze after the initial specification is approved, with new ideas captured in a future enhancements backlog for consideration after the MVP launches and we've validated core usage patterns.</p>" +
                "<p>Performance risk exists if template instantiation is slow or marketplace browsing is laggy. Creating a note from a template should be instant even for complex templates with hundreds of lines of content. Marketplace search should return results in under two hundred milliseconds even with thousands of templates. Our mitigation includes performance budgets defined upfront, load testing with simulated marketplace content, and optimization work prioritized in the development schedule before launch. If performance issues emerge, we'll implement caching, pagination, and lazy loading as needed.</p>" +
                "<p>Quality risk in the community marketplace could damage user trust. If the marketplace fills with spam, low-quality templates, or inappropriate content, users will stop using it. Our mitigation includes automated quality checks, rate limiting template submissions to prevent spam, clear community guidelines, and a reporting system for inappropriate content. Post-launch, we'll monitor marketplace submissions weekly and implement human curation if automated filters prove insufficient.</p>" +
                "<p><em>Next steps: Present this spec to engineering team on December 20th for technical feasibility review and effort estimation. Schedule design review with Morgan on December 22nd to finalize UI mockups. Begin development Sprint 14 on February 3rd pending successful collaboration feature launch.</em></p>",
                "feature-spec", "templates");

        createNote(user, "Sprint Planning Notes",
                "<p><strong><u>Sprint 13 Planning - Collaboration MVP Final Push</u></strong></p>" +
                "<p><em>Sprint Duration: December 23, 2024 - January 5, 2025 (two weeks including holiday period)</em></p>" +
                "<p><em>Planning Session Date: December 20, 2024 - Attendees: Alex (PM), Jamie (Dev), Morgan (Designer), Taylor (QA)</em></p>" +
                "<p>Sprint 13 represents the culmination of six months of work on real-time collaboration features for NotesApp. This sprint is make-or-break for our Q1 roadmap, as the collaboration MVP must be complete, tested, and ready for production deployment by January fifteenth. We're committing to the most ambitious sprint we've undertaken this year, with full awareness that we're planning during the holiday season when team capacity will be reduced. The successful delivery of this sprint will position NotesApp as a competitive player in the collaborative note-taking market and unlock significant revenue opportunities through team subscriptions.</p>" +
                "<p><strong>Sprint Goal and Strategic Context</strong></p>" +
                "<p>The overarching goal for Sprint 13 is to complete the real-time collaboration minimum viable product with all core features functional, tested across multiple browsers, and validated with at least one hundred concurrent users in our staging environment. This sprint is not about building new features beyond what's already scoped - it's about finishing, polishing, and validating what we've built over the previous three sprints. We need to ship production-ready code that our marketing team can confidently promote and our users can rely on for their daily collaboration needs.</p>" +
                "<p>Collaboration represents our biggest product bet of the year. We've invested approximately twelve thousand engineering hours and seventy-five thousand dollars in infrastructure costs to get to this point. The WebSocket server infrastructure is operational, the Yjs Conflict-Free Replicated Data Type library is integrated, and basic multi-user editing works in our development environment. What remains is hardening the implementation, ensuring reliability under load, building the user interface elements that make collaboration visible and understandable, and testing exhaustively to catch edge cases before users encounter them in production.</p>" +
                "<p>The timing of this sprint is both challenging and strategic. Planning a major sprint during the holiday season is risky because team members take time off and productivity naturally decreases. However, launching collaboration in mid-January positions us perfectly for the new year productivity surge when organizations set budgets and individuals commit to new workflows. If we delay this sprint to avoid the holidays, we'd miss the January window and push launch to February or later, losing crucial market timing and revenue opportunities.</p>" +
                "<p><strong>Committed User Stories and Work Breakdown</strong></p>" +
                "<p>Story COL-23 focuses on WebSocket connection management with intelligent auto-reconnect functionality. Currently, when a WebSocket connection drops due to network issues or server restarts, users lose real-time sync and must manually refresh the page. This story implements automatic reconnection with exponential backoff, connection health monitoring via periodic heartbeat messages, and graceful degradation when connections are unstable. The implementation requires changes to both frontend WebSocket client code and backend Hocuspocus server configuration. Estimated at eight story points, this is a moderately complex story requiring careful state management and thorough testing of edge cases like rapid connection loss and recovery. Jamie is assigned as the lead developer, with support from our backend infrastructure specialist.</p>" +
                "<p>Story COL-24 addresses real-time cursor position synchronization so collaborators can see where others are typing. This feature is critical for collaboration usability because without cursor visibility, users frequently edit the same sections simultaneously, causing confusion and merge conflicts. The implementation uses Yjs awareness protocol to broadcast cursor positions and selections across connected clients, then renders colored cursor indicators overlaid on the editor. Each user gets a randomly assigned color that persists throughout the session. The technical complexity is moderate at five story points, with most challenges in the UI rendering layer ensuring cursors don't interfere with normal editing and perform smoothly even with ten plus simultaneous users. Jamie owns the implementation with design support from Morgan for cursor styling and color selection.</p>" +
                "<p>Story COL-25 is the most complex and risky item in this sprint at thirteen story points: implementing Operational Transformation conflict resolution for simultaneous edits. When two users type in the same paragraph at the same time, their edits must be intelligently merged so both changes are preserved without corruption. We're leveraging the Yjs library which handles the complex transformation algorithms, but we need to integrate it properly with our TipTap editor, handle edge cases like simultaneous deletion and insertion at the same position, and test extensively with pathological scenarios. Jamie spent two days last week on a technical spike exploring Yjs integration, which significantly reduced technical risk. The fallback plan if full Operational Transformation proves too complex is implementing simple last-write-wins conflict resolution, which is less sophisticated but reliable and predictable.</p>" +
                "<p>Story COL-26 adds user presence indicators showing who is currently viewing or editing each note. The interface displays small avatar icons or initials in the note header for each active collaborator, with a tooltip showing full name and connection status. Presence information comes from Yjs awareness protocol, the same mechanism used for cursor positions. The story is estimated at three points as it's primarily frontend UI work with minimal backend changes. Morgan is the lead designer responsible for the visual design and React component implementation, with code review from Jamie to ensure the presence data is correctly consumed from the collaboration layer.</p>" +
                "<p>Story COL-27 implements error handling and user communication for collaboration session failures. When WebSocket connections fail, conflict resolution encounters errors, or users lose network connectivity, we need clear, helpful error messages that explain what happened and guide users toward resolution. The UI includes inline notifications for temporary connection issues, modal dialogs for serious errors requiring user action, and subtle indicators when collaborators disconnect or reconnect. This story is estimated at five points due to the number of error scenarios to handle and the UX design work required to communicate technical failures in user-friendly language. Morgan leads this work with input from Alex on messaging and tone.</p>" +
                "<p>Story COL-28 focuses on load testing with one hundred plus concurrent users to validate our infrastructure can handle production scale. We'll use load testing tools to simulate one hundred simultaneous users editing shared notes with realistic typing patterns, measuring WebSocket server CPU and memory usage, database query performance under concurrent writes, and client-side performance with multiple active collaborators per note. The testing will run for at least one hour to catch memory leaks or performance degradation over time. Jamie will set up the load tests using Artillery or K6 tools, analyze results, and identify any bottlenecks requiring optimization. This eight-point story is critical because it's our only opportunity to validate scalability before real users stress-test our production systems. If load testing reveals issues, we may need to add caching, optimize database queries, or adjust our AWS auto-scaling configuration.</p>" +
                "<p><strong>Sprint Capacity Planning and Team Availability</strong></p>" +
                "<p>Our total committed story points for Sprint 13 is forty-two points, which exceeds our historical three-sprint average velocity of thirty-eight points. This over-commitment is intentional but risky. We're betting that the technical spike work completed in Sprint 12 has reduced unknowns enough to increase our velocity. However, we're also operating during the holiday season when capacity is reduced, so we've calculated an adjusted capacity of thirty-two points assuming people take time off and productivity decreases. This creates a ten-point gap between commitment and realistic capacity, meaning we're likely to defer the two P1 stories, COL-26 and COL-27, if velocity drops as expected.</p>" +
                "<p>Jamie, our lead backend developer, will be at eighty percent capacity for this sprint due to taking December 25th and 26th off for the holiday. Even at reduced capacity, Jamie is critical to the sprint as all the P0 stories depend on backend WebSocket and Yjs integration work that only Jamie has deep expertise in. We've front-loaded Jamie's work in the first week so the most critical path items are completed before the holiday break. Morgan, our designer, is at full one hundred percent capacity and will focus on the UI stories COL-26 and COL-27, both of which can progress independently from Jamie's backend work. This parallelization maximizes overall team throughput.</p>" +
                "<p>Taylor, our QA engineer, is at only fifty percent capacity for this sprint because they're simultaneously supporting mobile app testing for another team. This reduced QA capacity is a concern because collaboration features require extensive testing across browsers, network conditions, and edge cases. To mitigate, we're implementing more automated testing than usual, with Jamie writing comprehensive integration tests for WebSocket connection scenarios and Morgan adding component tests for the presence and error handling UI. We'll also recruit two beta users to perform exploratory testing during the sprint, providing real-world feedback before the wider release.</p>" +
                "<p>Alex, the product manager, is available full-time for unblocking the team and managing stakeholder communications. Alex's primary responsibilities this sprint include clarifying requirements as questions arise, coordinating with the marketing team who need advance notice for launch planning, communicating progress and risks to executive leadership, and managing expectations if we need to defer features or adjust the launch timeline. Alex will also prepare launch materials including blog posts, user documentation, and customer support FAQs so everything is ready the moment development completes.</p>" +
                "<p><strong>Risk Assessment and Mitigation Strategies</strong></p>" +
                "<p>The thirteen-point Operational Transformation story COL-25 represents our highest technical risk. Transformation algorithms are notoriously complex, with subtle bugs that only manifest in specific concurrent editing scenarios. Our primary mitigation is using the battle-tested Yjs library rather than implementing transformation from scratch, reducing implementation risk by ninety percent. Jamie's two-day technical spike last week validated that Yjs integrates cleanly with our TipTap editor and handles the common conflict scenarios we've tested. However, there's always risk of encountering edge cases we haven't anticipated. Our fallback plan is implementing simple last-write-wins conflict resolution, which is less elegant but reliable. If we encounter blocking issues with Operational Transformation by December 28th, we'll make the call to switch to the fallback approach.</p>" +
                "<p>Holiday season capacity loss is our most certain risk with high probability and moderate impact. We've planned for twenty percent reduced capacity by committing thirty-two points worth of must-complete work and categorizing the remaining ten points as nice-to-have. The danger is if capacity drops more than twenty percent due to illness, personal emergencies, or underestimated holiday impact. Our mitigation is aggressive front-loading of critical path work in the first week, clear prioritization of P0 versus P1 stories, and daily check-ins to catch velocity issues early. If we're tracking behind by mid-sprint on December 30th, we'll immediately defer COL-26 and COL-27 to Sprint 14, ensuring the core collaboration functionality ships on time even if some polish is delayed.</p>" +
                "<p>Load testing discovering scalability issues is a low-to-medium probability risk with potentially severe impact if realized. If testing reveals our WebSocket server can't handle one hundred concurrent users, or database performance degrades unacceptably under load, we may need significant optimization work or infrastructure changes. We're mitigating by scheduling load testing early on day three of the sprint rather than at the end, giving us maximum time to address any issues discovered. Our AWS auto-scaling configuration is already set up and tested, providing automatic capacity expansion if CPU or memory utilization gets high. We've also budgeted five thousand dollars for emergency infrastructure upgrades if load testing reveals we need more powerful servers or additional caching layers.</p>" +
                "<p><strong>Sprint Ceremonies and Communication Cadence</strong></p>" +
                "<p>Daily standup meetings will occur every morning at 9:30am Pacific Time throughout the sprint. During the holiday week December 23rd through 27th, standups will shift to asynchronous Slack updates to accommodate people's time off and reduced schedule coordination. Each team member will post their yesterday accomplishments, today's plan, and any blockers by 10am Pacific. Alex will review all async updates and follow up synchronously with anyone who's blocked or needs support. We'll return to synchronous video standups on December 30th when the full team is back online.</p>" +
                "<p>Our mid-sprint check-in is scheduled for December 30th, the Monday after the holiday weekend. This check-in serves as a critical decision point where we assess actual progress against planned work and make scope adjustments if needed. We'll review burndown charts, update story estimates based on actual complexity encountered, and make final decisions about whether to defer P1 stories. This meeting is mandatory for all team members and will include a demo of work completed so far, giving stakeholders visibility into progress and building confidence we're on track.</p>" +
                "<p>The sprint review is scheduled for January 5th at 2pm Pacific, the final day of the sprint. We'll demonstrate all completed stories to stakeholders including the CEO, CTO, marketing director, and a board advisor who's been following collaboration development closely. The demo will show real-time collaboration working with multiple users editing the same note simultaneously, automatic conflict resolution, cursor synchronization, and presence indicators. We'll also present load testing results showing the system handling one hundred concurrent users without performance degradation. The review provides final approval to proceed with production deployment and marketing launch.</p>" +
                "<p>The sprint retrospective follows immediately after the review at 3:30pm Pacific on January 5th. This is a team-only session where we'll discuss what went well, what could be improved, and specific action items for Sprint 14. Given the complexity and high stakes of this sprint, the retrospective is especially important for capturing lessons learned about managing ambitious sprints during low-capacity periods, handling technical risks like Operational Transformation, and balancing speed with quality under deadline pressure.</p>" +
                "<p><strong>Definition of Done and Quality Standards</strong></p>" +
                "<p>Every story in this sprint must meet our comprehensive definition of done before it can be marked complete. Code must be reviewed by at least one other engineer and merged to the main branch with all CI checks passing. Unit tests are required with minimum eighty percent code coverage for new code paths. Integration tests must pass in our staging environment, which mirrors production configuration. QA testing must be completed on Chrome, Firefox, and Safari browsers on both Mac and Windows operating systems. The product owner, Alex, must accept each story by verifying it meets requirements and functions as specified. Finally, all relevant documentation must be updated including API documentation for backend changes and user guide updates for new features visible to end users.</p>" +
                "<p>This definition of done is non-negotiable even under time pressure. Past sprints where we relaxed quality standards to hit deadlines resulted in production bugs that cost more time to fix than we saved by cutting corners. We're committed to shipping quality code even if it means deferring features to the next sprint. The collaboration feature will be used by multiple users simultaneously, meaning bugs have multiplicative impact as they affect everyone in a collaborative session. A cursor synchronization bug that affects one user disrupts all collaborators on that note. Therefore, thorough testing and high quality standards are essential for this feature more than most.</p>" +
                "<p><strong>Success Criteria and Launch Readiness</strong></p>" +
                "<p>Sprint 13 will be deemed successful if all four P0 stories are completed to the definition of done: COL-23 WebSocket connection management, COL-24 cursor synchronization, COL-25 conflict resolution, and COL-28 load testing. These four stories represent the core collaboration functionality that must work reliably before we can launch. If the two P1 stories COL-26 presence indicators and COL-27 error handling UI are also completed, that's a bonus that improves the user experience, but they're not blockers for launch. We can ship a basic but functional collaboration MVP without presence indicators and add them in a follow-up release.</p>" +
                "<p>The collaboration feature must demonstrably work with two or more users editing the same note simultaneously without data loss, corruption, or crashes. Users should see each other's changes appear in real-time within one second of typing. Cursor positions should synchronize accurately showing where each collaborator is working. Simultaneous edits to the same paragraph should resolve correctly using Operational Transformation, preserving both users' contributions. The system must remain stable and performant even with ten users collaborating on a single note, though we expect typical usage to involve two to four collaborators most of the time.</p>" +
                "<p>We must have zero critical bugs in production, where critical is defined as data loss, crashes, security vulnerabilities, or complete feature failure. We can tolerate minor bugs like visual glitches or suboptimal error messages, which can be addressed in subsequent releases. However, anything that causes data loss or makes the feature unusable is a showstopper that delays launch until resolved. Our QA process and beta testing are designed to catch critical bugs before production deployment, but we'll also have a rapid response plan ready in case issues emerge after launch.</p>" +
                "<p>Finally, we must be ready for the marketing team to prepare and execute launch materials. This means the feature is complete enough to screenshot and demo in marketing videos, user documentation is written explaining how to use collaboration features, and we have a confident launch date we can commit to publicly. Marketing needs at least one week of lead time before announcing a major feature, so completion by January 5th enables a January 15th launch announcement with coordinated blog posts, email campaigns, and social media promotion.</p>" +
                "<p><em>Dependencies: No external dependencies. All infrastructure work including WebSocket servers, Yjs library integration, and database schema updates were completed in Sprint 12, giving Sprint 13 a clean foundation to build on.</em></p>" +
                "<p><em>Follow-up: Sprint 14 beginning January 6th will focus on bug fixes and polish based on stakeholder feedback from the sprint review, completing any deferred P1 stories, and beginning mobile app development to maintain Q1 roadmap momentum.</em></p>",
                "sprint-planning", "agile");

        createNote(user, "Competitive Analysis",
                "<p><strong><u>Competitive Landscape Analysis - Q4 2024 Update</u></strong></p>" +
                "<p><em>Analysis Date: December 18, 2024 - Analyst: Alex Smith, Product Manager</em></p>" +
                "<p><em>Competitors Evaluated: Notion, Evernote, Google Keep, Apple Notes, Obsidian, Roam Research</em></p>" +
                "<p>The note-taking and personal knowledge management market has evolved dramatically over the past five years, transforming from simple text storage tools into sophisticated productivity platforms. Our competitive analysis reveals a crowded marketplace with distinct segments: heavyweight all-in-one workspaces like Notion, traditional note-taking apps like Evernote, minimalist mobile-first options like Google Keep and Apple Notes, and emerging knowledge graph tools like Obsidian and Roam Research. NotesApp sits strategically between these segments, offering more power than minimalist apps but significantly less complexity than Notion, with a focus on collaboration that differentiates us from knowledge graph tools.</p>" +
                "<p>This analysis examines our competitive position across key feature dimensions, pricing strategies, user experience philosophy, and market positioning. We've conducted hands-on testing of all major competitors, analyzed user reviews and complaints, and surveyed our own users about their experiences with competitive products. The findings reveal clear opportunities where competitors are vulnerable and areas where we must catch up to remain competitive. Understanding this landscape is critical for Q1 2025 planning as we make strategic decisions about where to invest our limited engineering resources.</p>" +
                "<p><strong>Notion - The All-In-One Workspace Giant</strong></p>" +
                "<p>Notion dominates mindshare in the productivity space with an estimated ten million users and three hundred million dollar annual recurring revenue. Their all-in-one workspace approach combines notes, databases, wikis, project management, and collaboration into a single platform. This comprehensiveness is both Notion's greatest strength and its primary weakness. Users who invest time learning Notion's complex system become deeply committed, but new users face a steep learning curve that causes significant abandonment. Our user research shows that thirty-seven percent of people who tried Notion abandoned it within the first week because they found it overwhelming.</p>" +
                "<p>Notion's rich text editor is powerful and flexible, supporting everything from simple paragraphs to embedded databases and API integrations. However, this power comes at a performance cost - Notion feels sluggish compared to NotesApp, especially when working with large documents or complex database views. Users frequently complain about loading times and sync delays, particularly on mobile devices. Our speed advantage is a genuine differentiator that users notice immediately when switching from Notion to NotesApp. In side-by-side testing, NotesApp loads notes sixty-three percent faster than Notion on average.</p>" +
                "<p>Real-time collaboration is a mature feature in Notion, supporting unlimited simultaneous users with live cursors, comments, and presence indicators. They've invested heavily in collaboration infrastructure over the past three years, and it shows in the reliability and sophistication of their implementation. Our collaboration feature currently in development must match Notion's reliability to be credible, though we're not trying to match every advanced feature like threaded comments or page-level permissions. Users who need sophisticated collaboration with detailed permission controls will choose Notion. We're targeting users who want simple, reliable real-time co-editing without the complexity.</p>" +
                "<p>Notion's template system is extensive with thousands of community templates covering every imaginable use case from habit trackers to company wikis. However, template discovery is poor - the marketplace is cluttered and difficult to navigate, with no quality curation. Many templates are abandoned or poorly maintained. This represents an opportunity for NotesApp to build a better-curated, higher-quality template marketplace that prioritizes usefulness over quantity. Our research indicates users would prefer fifty excellent templates over five thousand mediocre ones.</p>" +
                "<p>Pricing is where Notion becomes expensive for teams. Individual users pay ten dollars per month, which is competitive, but team plans cost fifteen dollars per user per month with a minimum of three users. A ten-person team pays one hundred fifty dollars monthly or one thousand eight hundred annually. For price-sensitive teams, especially startups and small businesses, this becomes prohibitively expensive. NotesApp's planned team pricing at twelve dollars per user with no minimum provides a twenty percent cost advantage while maintaining profitability. If we can match Notion's core collaboration features at a lower price point with better performance, we can win cost-conscious teams.</p>" +
                "<p><strong>Evernote - The Declining Legacy Player</strong></p>" +
                "<p>Evernote pioneered the digital note-taking category fifteen years ago but has lost significant market share to more modern competitors. They peaked at around two hundred fifty million users in 2019 but have declined to approximately one hundred fifty million today, with user engagement metrics showing steady deterioration. The company has gone through multiple ownership changes, layoffs, and strategic pivots, creating uncertainty about long-term viability. Many former power users have migrated to Notion, Obsidian, or other alternatives, viewing Evernote as outdated and stagnant.</p>" +
                "<p>Evernote's rich text editor feels dated compared to modern alternatives. It lacks many formatting options users expect today, has occasional rendering bugs, and performs poorly with large attachments or complex formatting. The user interface hasn't been meaningfully updated in years and feels cluttered compared to cleaner modern designs. Our user research shows that former Evernote users cite the outdated interface as a primary reason for switching. NotesApp's modern, clean design gives us a significant advantage when competing for Evernote refugees.</p>" +
                "<p>Real-time collaboration is notably absent from Evernote, which remains fundamentally a single-user tool with basic sharing capabilities. You can share notes with others, but multiple people can't edit simultaneously - changes are asynchronous and can create conflicts. This is a major competitive weakness as collaboration becomes table stakes for productivity tools. Evernote announced collaboration features multiple times over the past five years but has repeatedly failed to deliver, damaging credibility with their user base. Our collaboration feature launch will position NotesApp as a superior alternative for users who outgrow Evernote's single-user limitations.</p>" +
                "<p>Evernote does have a mature template system with hundreds of pre-built templates for common scenarios. However, like their core product, the templates feel dated and aren't well integrated into the user experience. Finding and using templates requires multiple clicks through menus, and customizing templates is cumbersome. This is another area where NotesApp can deliver a significantly better experience with a modern template system designed for ease of use from the ground up.</p>" +
                "<p>Evernote's mobile apps for iOS and Android are functional but uninspiring. They have offline support, which is valuable, but the user interface is cramped and difficult to use on smaller screens. Sync is sometimes slow or unreliable, leading to user frustration and occasional data conflicts. Our planned mobile apps launching in Q1 have an opportunity to leapfrog Evernote's dated mobile experience with modern UI patterns, faster sync, and better offline support using local-first architecture.</p>" +
                "<p>Pricing has become a pain point for Evernote users. The free tier is extremely limited - only fifty notes and one device, making it essentially unusable for serious users. The personal plan costs eight dollars monthly or seventy dollars annually, which is competitive, but the feature set doesn't justify the price when compared to richer alternatives like Notion. Evernote is vulnerable to disruption from better products at similar or lower prices, which is exactly what NotesApp aims to deliver.</p>" +
                "<p><strong>Google Keep and Apple Notes - The Minimalist Incumbents</strong></p>" +
                "<p>Google Keep and Apple Notes represent the minimalist end of the market, prioritizing simplicity and speed over advanced features. Keep is deeply integrated into the Google ecosystem and excels at quick capture of simple notes, lists, and images. Apple Notes similarly integrates seamlessly with iOS and macOS, offering a native experience that third-party apps struggle to match. Both are free for their respective platform users, making them formidable competitors on price despite limited features.</p>" +
                "<p>The rich text editing in both Keep and Apple Notes is deliberately basic - just enough formatting to be useful without overwhelming users. Keep is particularly minimal, supporting only plain text, checkboxes, and images. Apple Notes is somewhat more capable with basic formatting, tables, and drawing tools, but still far simpler than Notion or NotesApp. This simplicity is intentional and appeals to users who want notes to just work without learning complex systems. However, users who outgrow these simple tools become candidates for NotesApp, representing a natural upgrade path.</p>" +
                "<p>Neither Google Keep nor Apple Notes offers real-time collaboration in the sense of simultaneous editing with live cursors. You can share notes and others can edit them, but edits happen asynchronously with potential conflicts. Apple Notes has basic collaboration via iCloud sharing, but it's unreliable and frequently results in sync conflicts or lost changes. This is a vulnerability we can exploit - users who need reliable collaboration must move to a dedicated collaboration tool like NotesApp or Notion.</p>" +
                "<p>Templates are completely absent from both Keep and Apple Notes. Users who need structured note formats must manually create and duplicate notes, or use third-party shortcuts and automation. This represents a clear feature gap that NotesApp's template system will address, providing structured note creation that Keep and Apple Notes users currently can't access without switching to more complex tools.</p>" +
                "<p>Mobile apps are where Keep and Apple Notes shine. As native first-party applications, they're deeply integrated into their respective operating systems, offering instant launch, perfect synchronization, and reliable offline support. Keep's widget support on Android is excellent, allowing note creation without even opening the app. Apple Notes similarly offers widgets, Siri integration, and handwriting support on iPad. Our mobile apps will need to deliver a comparably smooth experience to convince users to switch from the native apps they already have installed.</p>" +
                "<p>Pricing is unbeatable for Keep and Apple Notes - they're free for users of their respective platforms. This makes them default choices for casual users who don't need advanced features. However, both have limitations that drive power users to paid alternatives. Keep lacks any kind of formatting or organization beyond labels and colors. Apple Notes is locked into the Apple ecosystem, useless for Windows or Android users and teams with mixed platforms. NotesApp's cross-platform support and richer feature set justifies the nine dollar monthly price for users who outgrow free options.</p>" +
                "<p><strong>Obsidian and Roam Research - The Knowledge Graph Alternatives</strong></p>" +
                "<p>Obsidian and Roam Research represent a different philosophy: notes as a knowledge graph rather than a collection of documents. Both emphasize bidirectional linking between notes, creating a web of connected ideas rather than hierarchical folders or flat lists. This appeals strongly to researchers, writers, and knowledge workers who think in terms of interconnected concepts. However, the learning curve is steep and the use case is specialized, limiting these tools to a relatively small but passionate user base.</p>" +
                "<p>Obsidian's editor is markdown-based rather than WYSIWYG, appealing to technical users but alienating mainstream users who expect visual formatting. The app is extremely powerful with extensive plugin ecosystem, but this power requires significant learning investment. Roam Research similarly demands users learn its unique outliner-based interface and linking syntax. Both tools are fundamentally different from NotesApp's document-centric, visual editing approach. We're not directly competing for the same users - knowledge graph enthusiasts want different capabilities than NotesApp provides.</p>" +
                "<p>Real-time collaboration in Obsidian is complex and limited. The core app stores notes as local markdown files, making collaboration difficult without third-party sync solutions or paid Obsidian Sync service. Roam Research has better collaboration built-in but it's designed for asynchronous knowledge building rather than real-time document co-editing. Neither tool provides the Google Docs style simultaneous editing experience that NotesApp is building. Users who need that kind of collaboration workflow won't choose knowledge graph tools.</p>" +
                "<p>Templates exist in both Obsidian and Roam but they're technical - often requiring template syntax or plugin configuration. This appeals to power users who don't mind complexity, but mainstream users find it intimidating. NotesApp's visual, user-friendly template system will appeal to users who want template benefits without technical overhead.</p>" +
                "<p>Mobile apps are a weak point for both Obsidian and Roam. Obsidian's mobile apps exist but feel like desktop ports rather than mobile-first designs. Roam's mobile experience is notoriously poor, frequently cited as a major weakness in user reviews. Neither tool has invested heavily in mobile optimization, representing an opportunity for NotesApp to win users who need strong mobile support for knowledge management workflows.</p>" +
                "<p>Pricing varies significantly. Obsidian is free for personal use with optional paid sync and publishing features. Roam charges fifteen dollars per month or one hundred sixty-five dollars annually, positioning itself as a premium tool. Neither offers team plans with per-user pricing. NotesApp's nine dollar personal and twelve dollar team pricing sits competitively in this range while offering a more accessible user experience.</p>" +
                "<p><strong>Our Competitive Positioning and Differentiation Strategy</strong></p>" +
                "<p>NotesApp occupies a strategic position between minimalist tools like Keep and complex platforms like Notion. We're powerful enough for serious productivity work but simple enough to learn in minutes rather than hours. This middle ground appeals to users who have outgrown Keep and Apple Notes but find Notion overwhelming or expensive. Our focus on simplicity over feature bloat is a genuine differentiator in a market where competitors keep adding features without considering the cognitive overhead they create.</p>" +
                "<p>Speed and performance represent a significant competitive advantage. NotesApp loads notes faster than Notion, syncs more reliably than Evernote, and feels more responsive than any competitor except the native platform apps. In user testing, speed is consistently mentioned as a reason people prefer NotesApp. As competitors add features and accumulate technical debt, maintaining our performance advantage becomes increasingly valuable. We should resist adding features that compromise speed, even when users request them.</p>" +
                "<p>Our developer-friendly API is unique among competitors. While Notion has an API, it's complex and limited. Other competitors either lack APIs entirely or provide minimal capabilities. Our comprehensive, well-documented API appeals to technical users and enables integrations that extend NotesApp's value. We should continue investing in API quality and documentation, as this differentiates us in the developer community and enables ecosystem growth through third-party integrations.</p>" +
                "<p>The open roadmap approach where we share development plans publicly and incorporate user feedback creates transparency that builds trust. Competitors typically operate behind closed doors, announcing features only when ready to ship. Our approach makes users feel heard and invested in our success. This community-building strategy costs nothing but generates significant goodwill and user loyalty that's difficult for competitors to replicate.</p>" +
                "<p>Cross-platform support is essential for team users with mixed operating systems. Notion and Roam support all platforms but performance varies. Evernote supports all platforms but the experience is inconsistent. Keep is Android-centric, Apple Notes is iOS-centric. ObsidianWorks everywhere but mobile experiences are weak. NotesApp's commitment to high-quality experiences across web, Windows, Mac, iOS, and Android will appeal to teams tired of platform limitations or quality inconsistencies in competitor apps.</p>" +
                "<p><strong>Feature Comparison Summary and Strategic Gaps</strong></p>" +
                "<p>Rich text editing is table stakes - all competitors including NotesApp offer capable editors. We match or exceed competitor quality in this area. Real-time collaboration is currently our biggest gap - Notion has it, we're developing it. Launching collaboration in January eliminates this disadvantage and enables us to compete for team customers. Templates are a planned feature that will close another gap where Notion and Evernote currently lead. Mobile apps launching in Q1 address our most significant current weakness compared to established competitors.</p>" +
                "<p>Advanced features like databases, wikis, and project management tools offered by Notion are intentionally not on our roadmap. Adding these would compromise our simplicity advantage and position us in direct feature competition with a competitor that has more resources. We're better served focusing on doing note-taking and collaboration exceptionally well rather than becoming a mediocre everything app. Users who need databases should use Notion - we're not trying to serve every use case.</p>" +
                "<p>Offline support is critical for mobile users and currently missing from NotesApp. Evernote, Obsidian, and native apps all support offline mode. We must implement this in our mobile apps to be competitive, especially for users in areas with unreliable connectivity. The local-first architecture we're planning addresses this gap while providing performance benefits even for users with reliable internet.</p>" +
                "<p><strong>Competitive Threats and Market Risks</strong></p>" +
                "<p>The biggest threat is Notion improving performance and simplifying their user experience. If they successfully make Notion faster and easier to use while maintaining their feature richness, they could eliminate our primary differentiators. However, this is difficult - established products accumulate complexity that's hard to remove without alienating existing power users. Notion's incentive structure favors adding features over simplifying, giving us a sustained advantage if we maintain discipline.</p>" +
                "<p>A potential threat is Google or Apple investing seriously in Keep or Notes. Both companies have the resources to rapidly add features like templates and collaboration if they choose to compete seriously in this market. However, neither has shown strong interest in evolving these products beyond simple note-taking. Keep and Notes appear to be strategic assets for ecosystem lock-in rather than growth businesses. We should monitor for signs of increased investment but not alter strategy based on hypothetical threats.</p>" +
                "<p>New entrants are always a risk in software markets with low barriers to entry. However, note-taking has strong network effects - users with extensive note libraries face high switching costs. Collaboration features increase lock-in as teams standardize on shared workflows. By building a loyal user base now and shipping collaboration and mobile apps in Q1, we create defensibility against future competitors.</p>" +
                "<p><em>Next review: March 2025 after Q1 feature launches complete. Will reassess competitive landscape with particular focus on how competitors respond to our collaboration and mobile launches.</em></p>",
                "competitive-analysis", "strategy");
    }

    private void createDeveloperNotes(User user) {
        createNote(user, "API Documentation - Authentication",
                "<p><strong><u>Authentication API Reference Documentation</u></strong></p>" +
                "<p><em>Base URL: https://api.notesapp.com - Last Updated: December 19, 2024</em></p>" +
                "<p><em>Maintainer: Jamie Lee, Backend Engineer - Version: 2.1</em></p>" +
                "<p>The NotesApp Authentication API provides secure user authentication and session management using industry-standard JWT tokens stored in httpOnly cookies. This design provides robust security against cross-site scripting attacks while maintaining excellent usability and compatibility with modern frontend frameworks. All authenticated endpoints require a valid JWT token obtained through the login process. The authentication system supports both traditional email and password authentication as well as OAuth2 integration with Google and other providers for single sign-on capabilities.</p>" +
                "<p>Our authentication architecture prioritizes security without sacrificing developer experience. JWT tokens are cryptographically signed using HS256 algorithm with a secret key stored securely in environment variables. Tokens expire after seven days, striking a balance between security and user convenience. The httpOnly cookie approach means frontend JavaScript cannot access the token, preventing common XSS-based token theft attacks. Meanwhile, CORS configuration ensures tokens are only sent to trusted domains, protecting against cross-site request forgery.</p>" +
                "<p><strong>Account Registration Endpoint Details</strong></p>" +
                "<p>The registration endpoint at POST /api/auth/register creates new user accounts within the NotesApp system. All new accounts are subject to admin approval before they can be used for login, providing a layer of quality control and spam prevention. This approval workflow is particularly important for enterprise deployments where administrators need visibility into who is accessing the system. The endpoint accepts a JSON payload containing name, email, and password fields, all of which undergo validation before the account is created.</p>" +
                "<p>Registration requests are rate-limited to five attempts per fifteen-minute window per IP address. This aggressive rate limiting prevents automated account creation attacks and reduces spam registrations. The rate limit is tracked in Redis with a sliding window algorithm that provides smooth limiting behavior rather than sudden cutoffs at arbitrary time boundaries. If a user exceeds the rate limit, they receive a 429 Too Many Requests response with a Retry-After header indicating how long to wait before trying again.</p>" +
                "<p>Name validation ensures the provided name is between two and one hundred characters long, preventing both trivially short names and unreasonably long names that could cause UI layout issues. Email validation uses a comprehensive regex pattern that covers all legitimate email formats according to RFC 5322 specification while rejecting obviously invalid formats. We also check email uniqueness against the database - duplicate email addresses are rejected with a 409 Conflict response since each email can only be associated with one account.</p>" +
                "<p>Password validation enforces strong password requirements to protect user accounts from compromise. Passwords must be at least eight characters long and contain at least one uppercase letter, one lowercase letter, one numeric digit, and one special character from the set of allowed punctuation marks. This complexity requirement significantly increases the difficulty of brute force and dictionary attacks while remaining achievable for users. The frontend provides real-time feedback as users type, helping them create compliant passwords without frustrating trial and error.</p>" +
                "<p>Upon successful registration, the API returns a 200 OK response with a JSON body indicating the account was created but is pending admin approval. The user receives an email confirmation acknowledging their registration and explaining that an administrator will review their account within one business day. Administrators receive a notification email with the new account details and links to approve or reject the account through the admin dashboard. Until approval, any login attempts with the pending account credentials return a 403 Forbidden response with a clear message about pending approval status.</p>" +
                "<p><strong>Login Authentication Flow</strong></p>" +
                "<p>The login endpoint at POST /api/auth/login authenticates users with their email and password credentials and establishes an authenticated session via JWT token. This endpoint is public and does not require any existing authentication. Upon successful login, the server generates a JWT token containing the user's ID, email, roles, and expiration timestamp, then sets this token as an httpOnly cookie in the response. The frontend receives the cookie automatically and will include it in all subsequent requests to authenticated endpoints.</p>" +
                "<p>Login attempts are rate-limited to ten requests per five-minute window per email address. This tighter rate limit specifically targets brute force password guessing attacks where an attacker tries many passwords against a single account. The rate limit is per-email rather than per-IP to prevent IP rotation attacks while allowing legitimate users on shared IPs to login without interference. After hitting the rate limit, further login attempts for that email address are blocked for the full five-minute window regardless of whether the password is correct.</p>" +
                "<p>The authentication process involves several steps to ensure security. First, the email is used to query the database for a matching user account. If no account exists with that email, the authentication fails immediately with a generic error message indicating invalid credentials. We intentionally use the same error message for non-existent accounts and incorrect passwords to prevent account enumeration attacks where an attacker could determine which email addresses have accounts.</p>" +
                "<p>For existing accounts, the stored password hash is compared against the provided password using BCrypt comparison with a cost factor of twelve. BCrypt is specifically designed for password hashing with built-in salt generation and computational hardening that makes brute force attacks extremely expensive. The cost factor of twelve means the hashing operation takes approximately two hundred fifty milliseconds on modern server hardware, enough to slow down mass password cracking while remaining imperceptible to users during normal login. This timing must be consistent regardless of password match to prevent timing attacks that could leak information about password correctness.</p>" +
                "<p>If the password matches, the system checks the account's approval status before allowing login. Accounts that are still pending approval or have been explicitly rejected by administrators cannot login even with correct credentials. Pending accounts receive a 403 Forbidden response explaining the account is awaiting approval. Rejected accounts receive a similar response explaining the account has been declined, along with instructions for contacting support if they believe this was an error. These status checks prevent unauthorized access while providing clear feedback to users about their account state.</p>" +
                "<p>Successful authentication generates a JWT token signed with our secret key. The token payload includes the user ID as the subject, the user's email, an array of roles for authorization purposes, the issue timestamp, and the expiration timestamp seven days in the future. The token is set as a cookie named jwt with flags HttpOnly to prevent JavaScript access, Secure to require HTTPS transmission, SameSite equals None to allow cross-origin requests from our frontend domain, and Max-Age set to seven days matching the token expiration. The response also includes a JSON body with the user object containing ID, name, email, and roles for immediate frontend use.</p>" +
                "<p><strong>Session Management and Logout</strong></p>" +
                "<p>The logout endpoint at POST /api/auth/logout terminates the current authenticated session by invalidating the JWT cookie. This endpoint requires authentication, meaning the user must have a valid JWT token to logout. While this might seem circular, it prevents unauthorized logout attacks where a malicious actor logs out legitimate users. The logout process is straightforward - the server responds with a Set-Cookie header that sets the jwt cookie to an empty value with Max-Age equals zero, causing the browser to immediately delete the cookie.</p>" +
                "<p>Client applications should call the logout endpoint whenever users explicitly request to logout through UI actions like clicking a Logout button. After receiving the logout response, the frontend should clear any cached user data and redirect to the login page or public homepage. The now-deleted cookie ensures subsequent requests to authenticated endpoints will fail with 401 Unauthorized responses, properly enforcing the logged-out state across the application.</p>" +
                "<p>Token expiration provides additional security by limiting the lifetime of stolen tokens. If an attacker somehow obtains a user's JWT token, they can only use it until its expiration seven days after issuance. The frontend should handle 401 Unauthorized responses gracefully by clearing local state and redirecting users to login. We deliberately chose seven days as a balance between security and user convenience - shorter expiration would be more secure but require frequent re-authentication, while longer expiration would be more convenient but increase the window of vulnerability for compromised tokens.</p>" +
                "<p><strong>User Information Endpoint</strong></p>" +
                "<p>The current user endpoint at GET /api/auth/me returns detailed information about the currently authenticated user. This endpoint requires authentication and uses the JWT token to identify which user to return information about. The response includes user ID, full name, email address, roles array, authentication provider indicating whether the account uses password authentication or OAuth2, email verification status, account approval status, and the account creation timestamp. This comprehensive information allows frontends to personalize the user interface and implement role-based access control for UI elements.</p>" +
                "<p>Frontend applications typically call this endpoint immediately after page load to determine if the user has an active session. If the request succeeds with 200 OK, the user is logged in and the returned data populates the application state. If the request fails with 401 Unauthorized, no valid session exists and the frontend should show login UI. This pattern provides seamless session restoration when users return to the application after closing and reopening their browser, as long as the JWT cookie has not expired.</p>" +
                "<p>The endpoint also serves as a health check for session validity. Applications can call it periodically or before critical operations to confirm the session is still active. This is particularly useful in single-page applications where users might leave the app open for extended periods spanning token expiration. Detecting expired sessions proactively allows graceful handling with user-friendly prompts to re-authenticate rather than unexpected errors when attempting authenticated operations.</p>" +
                "<p><strong>WebSocket Authentication Token Generation</strong></p>" +
                "<p>Real-time collaboration features require WebSocket connections which cannot use httpOnly cookies for authentication due to protocol limitations. The WebSocket token endpoint at POST /api/auth/ws-token solves this by generating a temporary single-use token specifically for WebSocket authentication. This endpoint requires authentication via the standard JWT cookie, ensuring only authenticated users can obtain WebSocket tokens. The request body must include a noteId parameter specifying which note the WebSocket connection will be used for.</p>" +
                "<p>The generated WebSocket token is a JWT signed with the same secret key as regular auth tokens but with a very short expiration of only one hour. The token payload includes the note ID, user ID, and expiration timestamp. This limited scope token can only be used to establish a WebSocket connection for the specified note, preventing token reuse for unintended purposes. If an attacker intercepts a WebSocket token, they can only access that single note for at most one hour, significantly limiting the impact compared to a full session token.</p>" +
                "<p>Before generating the token, the server verifies the requesting user has permission to access the specified note through our authorization service. Users can only obtain WebSocket tokens for notes they own or notes that have been shared with them. Attempting to request a token for a note the user cannot access results in a 403 Forbidden response. This authorization check prevents users from establishing WebSocket connections to notes they shouldn't be able to view or edit, maintaining our security model in real-time collaboration scenarios.</p>" +
                "<p>The frontend receives the WebSocket token in the response and immediately uses it to establish a WebSocket connection by including the token as a query parameter in the WebSocket URL. The Hocuspocus collaboration server validates this token before accepting the connection, ensuring only authorized users can join collaborative editing sessions. Once connected, the WebSocket remains open for the duration of the editing session or until disconnection occurs. If the connection drops and reconnection is needed after token expiration, the frontend must request a new WebSocket token through this endpoint.</p>" +
                "<p><strong>Security Considerations and Best Practices</strong></p>" +
                "<p>All authentication endpoints implement comprehensive security measures to protect against common attack vectors. Cross-Origin Resource Sharing CORS is configured to allow credentials only from our whitelisted frontend domains, preventing unauthorized websites from calling our API with user credentials. The configuration includes specific allowed origins rather than wildcard, specific allowed methods and headers, and credentials support enabled for cookie transmission. This strict CORS policy prevents numerous attack vectors while allowing our legitimate frontend to function correctly.</p>" +
                "<p>Rate limiting protects against brute force attacks and API abuse. Different endpoints have different rate limits based on their risk profile - registration is most tightly limited at five per fifteen minutes, login is limited to ten per five minutes, while information retrieval endpoints like GET /api/auth/me have more generous limits. Rate limits are tracked in Redis using the user's IP address or email as the key, with automatic expiration when the rate limit window elapses. Responses to rate-limited requests include Retry-After headers specifying when the client can try again.</p>" +
                "<p>Password security begins at storage with BCrypt hashing at cost factor twelve. This computational cost means each password hash takes approximately two hundred fifty milliseconds to generate or verify, making mass password cracking economically infeasible even with modern GPU-based cracking tools. The salt is automatically generated by BCrypt for each password and stored within the hash output, preventing rainbow table attacks. Passwords are never logged or stored in plaintext anywhere in the system, and database backups containing password hashes are encrypted at rest.</p>" +
                "<p>Failed authentication attempts are logged for security monitoring and incident response. Each failed login attempt generates a log entry including the attempted email, the source IP address, the timestamp, and the failure reason. This log data feeds into our security monitoring dashboards where we track suspicious patterns like repeated failed attempts from the same IP or attempts against many different accounts from the same source. Automated alerting triggers when attack patterns are detected, allowing security team response before significant damage occurs.</p>" +
                "<p>Token transmission uses HTTPS exclusively in production environments. The Secure flag on JWT cookies ensures they are only transmitted over encrypted connections, preventing interception through man-in-the-middle attacks on insecure networks. All production API endpoints enforce HTTPS through automatic redirection of HTTP requests and HTTP Strict Transport Security headers that instruct browsers to always use HTTPS for our domain. Development environments allow HTTP for local testing convenience but production configuration mandates encryption for all authentication traffic.</p>" +
                "<p><em>For additional API documentation covering notes management, tags, collaboration, and admin endpoints, see the full API documentation at https://docs.notesapp.com/api</em></p>",
                "api-docs", "authentication");

        createNote(user, "Bug Tracker - WebSocket Issues",
                "<h2> Active Bugs - Collaboration Feature</h2>" +
                "<p><em>Last updated: December 19, 2024</em></p>" +
                "<hr>" +
                "<h3>BUG-156: WebSocket Connection Drops After Inactivity</h3>" +
                "<p><strong>Status:</strong> <span style='background:#EF4444;color:white;padding:4px 8px;border-radius:4px;font-weight:bold;'>CRITICAL - P0</span></p>" +
                "<p><strong>Reporter:</strong> Alice Chen (QA Engineer)</p>" +
                "<p><strong>Assigned To:</strong> Jamie Lee (Backend Dev)</p>" +
                "<p><strong>Created:</strong> December 18, 2024 | <strong>Updated:</strong> December 19, 2024</p>" +
                "<p><strong>Affected Version:</strong> v1.2.0-beta | <strong>Target Fix:</strong> v1.2.1</p>" +
                "<h4> Description</h4>" +
                "<p>WebSocket connections for real-time collaboration are intermittently dropping after 5-10 minutes of user inactivity. When the connection drops, users continue editing locally but changes don't sync to other collaborators. No error message is shown to the user, leading to data conflicts when reconnection occurs.</p>" +
                "<p><strong>Impact:</strong> 45% of collaborative sessions affected. Users lose work or experience merge conflicts.</p>" +
                "<h4> Steps to Reproduce</h4>" +
                "<ol>" +
                "<li>Open a collaborative note with 2+ users</li>" +
                "<li>Both users make initial edits (verify sync is working)</li>" +
                "<li>Stop typing for exactly 10 minutes (no keyboard/mouse activity)</li>" +
                "<li>User A types new content</li>" +
                "<li><strong>Expected:</strong> User B sees changes in real-time</li>" +
                "<li><strong>Actual:</strong> User B sees no changes. Console shows \"WebSocket disconnected\"</li>" +
                "</ol>" +
                "<p><strong>Reproducibility:</strong> 8/10 attempts (80%)</p>" +
                "<h4> Root Cause Analysis</h4>" +
                "<p>After investigating server logs and network traces, identified the following:</p>" +
                "<ol>" +
                "<li><strong>Primary cause:</strong> Nginx reverse proxy has default <code>proxy_read_timeout 60s</code> which closes idle WebSocket connections</li>" +
                "<li><strong>Secondary cause:</strong> Our Hocuspocus server doesn't send periodic pings to keep connection alive</li>" +
                "<li><strong>Frontend issue:</strong> Client doesn't detect disconnection and attempt auto-reconnect</li>" +
                "</ol>" +
                "<p><strong>Technical Details:</strong></p>" +
                "<pre><code>// Nginx error log shows:\n" +
                "[error] 12345#12345: *678 upstream timed out (110: Connection timed out) \n" +
                "while reading upstream, client: 192.168.1.10, server: notesapp.com, \n" +
                "request: \"GET /collaboration HTTP/1.1\", upstream: \"http://127.0.0.1:1234/\"\n\n" +
                "// Client console shows (after ~60s of inactivity):\n" +
                "WebSocket connection to 'wss://notesapp.com/collaboration' failed: \n" +
                "Error during WebSocket handshake: net::ERR_CONNECTION_RESET</code></pre>" +
                "<h4> Proposed Solution</h4>" +
                "<p><strong>Multi-layered fix (defense in depth):</strong></p>" +
                "<p><strong>1. Nginx Configuration Update:</strong></p>" +
                "<pre><code># /etc/nginx/sites-available/notesapp\n" +
                "location /collaboration {\n" +
                "    proxy_pass http://localhost:1234;\n" +
                "    proxy_http_version 1.1;\n" +
                "    proxy_set_header Upgrade $http_upgrade;\n" +
                "    proxy_set_header Connection \"upgrade\";\n" +
                "    \n" +
                "    # Increase timeout for WebSocket connections\n" +
                "    proxy_read_timeout 3600s;  # 1 hour\n" +
                "    proxy_send_timeout 3600s;\n" +
                "    \n" +
                "    # Disable buffering for real-time communication\n" +
                "    proxy_buffering off;\n" +
                "}</code></pre>" +
                "<p><strong>2. Server-side Ping Implementation:</strong></p>" +
                "<pre><code>// hocuspocus-server/server.js\n" +
                "const server = Server.configure({\n" +
                "  // Send ping every 30 seconds to keep connection alive\n" +
                "  timeout: 30000,\n" +
                "  \n" +
                "  onConnect(data) {\n" +
                "    console.log('Client connected:', data.documentName);\n" +
                "    \n" +
                "    // Set up interval for heartbeat\n" +
                "    data.connection.heartbeat = setInterval(() => {\n" +
                "      if (data.connection.readyState === 1) {\n" +
                "        data.connection.ping();\n" +
                "      }\n" +
                "    }, 25000); // Ping every 25s (before 60s timeout)\n" +
                "  },\n" +
                "  \n" +
                "  onDisconnect(data) {\n" +
                "    if (data.connection.heartbeat) {\n" +
                "      clearInterval(data.connection.heartbeat);\n" +
                "    }\n" +
                "  }\n" +
                "});</code></pre>" +
                "<p><strong>3. Client-side Auto-reconnect:</strong></p>" +
                "<pre><code>// frontend/src/utils/collaborationManager.js\n" +
                "const provider = new HocuspocusProvider({\n" +
                "  url: 'wss://notesapp.com/collaboration',\n" +
                "  name: noteId,\n" +
                "  \n" +
                "  // Auto-reconnect configuration\n" +
                "  onDisconnect: ({ event }) => {\n" +
                "    console.warn('WebSocket disconnected, attempting reconnect...');\n" +
                "    showNotification('Connection lost. Reconnecting...', 'warning');\n" +
                "  },\n" +
                "  \n" +
                "  onConnect: () => {\n" +
                "    console.log('WebSocket connected');\n" +
                "    showNotification('Connected to collaboration server', 'success');\n" +
                "  },\n" +
                "  \n" +
                "  // Reconnect automatically with exponential backoff\n" +
                "  maxReconnectAttempts: 10,\n" +
                "  reconnectDelay: 1000, // Start with 1s\n" +
                "});</code></pre>" +
                "<h4> Testing Checklist</h4>" +
                "<ul>" +
                "<li> Deploy Nginx config changes to staging</li>" +
                "<li> Test 15-minute idle period (3x the timeout)</li>" +
                "<li> Verify heartbeat pings in browser Network tab</li>" +
                "<li> Test with 5 concurrent users, varying idle times</li>" +
                "<li> Verify error messages show properly to users</li>" +
                "<li> Load test: 100 concurrent WebSocket connections</li>" +
                "<li> Monitor server logs for 24 hours after deployment</li>" +
                "</ul>" +
                "<h4> Validation Metrics</h4>" +
                "<ul>" +
                "<li><strong>Before fix:</strong> 45% of sessions experience disconnection</li>" +
                "<li><strong>Target after fix:</strong> <2% disconnection rate</li>" +
                "<li><strong>Success criteria:</strong> No disconnections during 30-minute idle test</li>" +
                "</ul>" +
                "<h4> Deployment Plan</h4>" +
                "<ol>" +
                "<li>Deploy to staging (Dec 20, 2pm PT) - Jamie</li>" +
                "<li>QA testing (Dec 20-21) - Alice</li>" +
                "<li>Production deployment (Dec 22, 11am PT during low traffic) - Jamie</li>" +
                "<li>Monitor for 48 hours - On-call rotation</li>" +
                "</ol>" +
                "<h4> Comments</h4>" +
                "<p><strong>Jamie (Dec 19, 3:15pm):</strong> Implemented heartbeat in hocuspocus-server. Tested locally for 20 minutes - no disconnections. Ready for staging.</p>" +
                "<p><strong>Alex (PM, Dec 19, 4:30pm):</strong> Great work! This blocks our Jan 15 launch. Please prioritize QA testing.</p>" +
                "<p><strong>Alice (Dec 19, 5:00pm):</strong> Will test tomorrow with multiple browsers (Chrome, Firefox, Safari). Will also test on slow 3G network.</p>" +
                "<hr>" +
                "<h3>Other Open Bugs</h3>" +
                "<ul>" +
                "<li><strong>BUG-157:</strong> Cursor colors clash when 5+ users collaborate (P2, Morgan assigned)</li>" +
                "<li><strong>BUG-158:</strong> Code block syntax highlighting breaks with certain languages (P3, deferred to Sprint 14)</li>" +
                "<li><strong>BUG-159:</strong> Mobile Safari: Editor toolbar obscured by keyboard (P1, mobile team)</li>" +
                "</ul>",
                "bug", "websocket", "collaboration");

        createNote(user, "Code Review Checklist",
                "<p><strong><u>Code Review Guidelines and Best Practices</u></strong></p>" +
                "<p><em>Last updated: December 2024 | Applies to all pull requests</em></p>" +
                "<p>Code reviews are one of the most important quality gates in our development process. A thorough code review catches bugs before they reach production, ensures code maintainability, spreads knowledge across the team, and maintains consistent coding standards. Every pull request must be reviewed by at least one other engineer before merging to main. For critical features or complex changes, we require two reviewers.</p>" +
                "<p><strong>Code Quality Standards</strong></p>" +
                "<p>First and foremost, all code must follow our team style guide. We use ESLint for JavaScript and Prettier for auto-formatting, so most style issues should be caught automatically. However, reviewers should still check for consistent naming conventions, proper indentation in areas the linter might miss, and overall code organization. If you find yourself fighting with the linter rules, that's a sign we should discuss updating our style guide rather than bypassing the rules.</p>" +
                "<p>One of the biggest red flags in code review is commented-out code. If code is no longer needed, delete it. We have git history if we need to recover it later. Commented code clutters the codebase and creates confusion about whether it's meant to be temporary or if someone forgot to remove it. The only acceptable comments are explanatory comments that describe why we're doing something non-obvious, not what the code does.</p>" +
                "<p>Console.log statements should never make it to production. We have a proper logging system using Winston for backend and our custom logger for frontend. During development, console.log is fine for quick debugging, but before submitting a PR, search your changes for console.log and remove them all. Our pre-commit hook should catch most of these, but it's your responsibility as the author to clean up debug code before review.</p>" +
                "<p>Variable and function names must be meaningful and self-documenting. Avoid single-letter variables except for loop indices and mathematical formulas where conventions are clear. A variable named userData is better than d or info. A function named calculateTotalRevenue is better than calc or process. Names should reveal intent - someone reading the code six months from now should understand what a variable represents without running the code.</p>" +
                "<p>Functions should be focused and concise, ideally under fifty lines. If a function is longer than fifty lines, it's probably doing too much and should be broken into smaller functions. Each function should do one thing well. This makes code easier to test, easier to understand, and easier to modify. When reviewing, if you find yourself getting lost in a long function, ask the author to refactor it into smaller, more focused pieces.</p>" +
                "<p><strong>Testing Requirements</strong></p>" +
                "<p>Every new function or method must have corresponding unit tests. We aim for at least eighty percent code coverage, but coverage alone isn't enough - tests must be meaningful. A test that simply calls a function and asserts it doesn't throw an error isn't valuable. Tests should verify that functions behave correctly with various inputs, including edge cases.</p>" +
                "<p>When reviewing tests, check that they follow the Arrange-Act-Assert pattern. Set up test data, execute the function being tested, then assert the expected outcome. Tests should be independent - running tests in any order should produce the same results. If tests rely on shared state or must run in a specific order, that's a problem that needs fixing.</p>" +
                "<p>Integration tests are just as important as unit tests. While unit tests verify individual functions work correctly in isolation, integration tests verify that components work together properly. For example, an integration test might verify that when a user creates a note via the API, it's correctly saved to the database and can be retrieved. All integration tests must pass before merging.</p>" +
                "<p>Edge cases are where bugs hide. When reviewing tests, think about boundary conditions, null inputs, empty arrays, very large inputs, and error conditions. If a function accepts a number parameter, what happens with zero, negative numbers, or infinity? If it accepts a string, what about empty strings or very long strings? Good tests cover these cases.</p>" +
                "<p><strong>Documentation Expectations</strong></p>" +
                "<p>All public API functions must have JSDoc comments describing what they do, what parameters they accept, and what they return. This isn't just for documentation generation - it helps developers understand how to use functions without reading the implementation. When reviewing, if you find yourself confused about what a function does or how to call it, that's a sign it needs better documentation.</p>" +
                "<p>If the pull request changes user-facing features or adds new capabilities, the README file must be updated. Users shouldn't have to dig through code to discover new features. Documentation should be written from the user's perspective - what problem does this solve, how do I use it, what should I watch out for. Technical implementation details belong in code comments, not user documentation.</p>" +
                "<p>Every pull request must include a changelog entry describing what changed and why. We follow the Keep a Changelog format with categories like Added, Changed, Deprecated, Removed, Fixed, and Security. Changelog entries should be written for end users and other developers, not just the person who made the change. Six months from now, someone will read this changelog to understand when a feature was added or a bug was fixed.</p>" +
                "<p><strong>Performance Considerations</strong></p>" +
                "<p>When reviewing code, always think about performance implications. Is this code being called in a loop? Could this database query cause an N+1 problem? Is this component re-rendering unnecessarily? Performance bugs are harder to fix after they're in production, so catch them in review. If you spot potential performance issues, bring them up even if the code is functionally correct.</p>" +
                "<p>Database queries deserve special attention. Look for missing indexes, inefficient joins, or queries that fetch more data than needed. A query that works fine with one hundred rows might grind to a halt with ten thousand rows. If a PR adds or modifies database queries, ask the author if they've tested with realistic data volumes. Consider suggesting the addition of indexes if queries are filtering or sorting on unindexed columns.</p>" +
                "<p>Frontend performance matters too. Large bundle sizes slow down page loads, especially on mobile connections. If a PR adds new dependencies, check their size using bundlephobia.com. A five hundred kilobyte library to do something we could implement in fifty lines isn't worth it. Similarly, watch for expensive operations in render methods or effects that run too frequently.</p>" +
                "<p><strong>Security Review</strong></p>" +
                "<p>Security must be top of mind during code review. Check for SQL injection vulnerabilities by ensuring all database queries use parameterized queries, never string concatenation. Check for XSS vulnerabilities by ensuring user input is properly escaped before rendering in HTML. Check for authentication and authorization - are we verifying the user has permission to perform this action?</p>" +
                "<p>Sensitive data like passwords, API keys, and tokens must never be logged or stored in plain text. Passwords should be hashed using bcrypt, API keys should be stored in environment variables, and secrets should never be committed to the repository. If you see a hardcoded API key or password in a PR, reject it immediately and remind the author about our security policies.</p>" +
                "<p><strong>The Review Process</strong></p>" +
                "<p>Start by reading the PR description and understanding what problem this code is solving. Then read through the changes carefully, looking for bugs, style issues, and opportunities for improvement. Don't just scan for obvious problems - think critically about edge cases and potential issues. Take your time. A rushed review that misses bugs helps no one.</p>" +
                "<p>When leaving comments, be specific and constructive. Instead of just saying this code is bad, explain why it's problematic and suggest an alternative. Frame feedback as questions when possible - could we simplify this by doing X instead of Y? This invites discussion rather than creating defensiveness. Remember that code review is a conversation between professionals, not a lecture.</p>" +
                "<p>Use the appropriate severity level for comments. Mark critical issues like security vulnerabilities or bugs as must fix before merging. Mark style issues or minor improvements as optional suggestions. Don't block a PR for tiny nits that don't affect functionality. If you find yourself leaving lots of style comments, maybe we need to update our linter configuration instead.</p>" +
                "<p>When your code is being reviewed, don't take feedback personally. The reviewer is trying to help improve the code and catch problems before they reach users. Thank them for their time and engage thoughtfully with their suggestions. If you disagree with feedback, explain your reasoning. Sometimes the reviewer is missing context, and sometimes you're missing something they caught. Healthy discussion makes both of you better engineers.</p>" +
                "<p><em>These guidelines will evolve as our team and codebase grow. If you have suggestions for improving our code review process, bring them up in our weekly engineering meeting.</em></p>",
                "code-review", "best-practices", "engineering");

        createNote(user, "Database Schema Design",
                "<p><strong>Designing a Robust Database Schema for Modern Web Applications</strong></p>" +
                "<p>When architecting a full-stack application, the database schema serves as the foundation upon which all other components are built. A well-designed schema ensures data integrity, optimizes query performance, and provides the flexibility needed for future growth. In this comprehensive analysis, we'll explore the intricacies of database design for a note-taking application, examining the core tables, relationships, and design decisions that enable scalable and maintainable data persistence.</p>" +
                "<p>The <strong>users table</strong> represents the cornerstone of our authentication and authorization system. Each user record contains a unique identifier implemented as a <em>BIGINT PRIMARY KEY with AUTO_INCREMENT</em>, ensuring that every user receives a sequential, system-generated ID that serves as the primary reference throughout the database. The email field is defined as <em>VARCHAR(255) with a UNIQUE constraint</em>, guaranteeing that no two users can register with the same email address while providing efficient lookup capabilities for login operations. This uniqueness constraint is critical for authentication flows, where email addresses serve as the primary identifier for user accounts.</p>" +
                "<p>The name field, also defined as <em>VARCHAR(255) NOT NULL</em>, stores the user's display name and is required for all accounts. The password field, defined as <em>VARCHAR(255)</em> without a NOT NULL constraint, accommodates both traditional email-password authentication and OAuth-based authentication flows. When users authenticate via Google OAuth, the password field remains NULL, as authentication is delegated to the external provider. This flexible design allows our application to support multiple authentication strategies without requiring schema modifications.</p>" +
                "<p>The roles field utilizes a <em>VARCHAR(255)</em> type to store user roles in a comma-separated format, such as <u>USER,ADMIN</u> or simply <u>USER</u>. While this denormalized approach sacrifices some normalization principles, it provides excellent query performance for authorization checks, which occur on every authenticated request. The provider field, defined as <em>VARCHAR(50)</em>, tracks the authentication provider used during registration, storing values like <u>local</u> for email-password authentication or <u>google</u> for OAuth-based signups. This information is essential for managing account security and understanding user authentication preferences.</p>" +
                "<p>The account_approved field, implemented as a <em>BOOLEAN with DEFAULT FALSE</em>, enables manual account approval workflows. In production environments where user onboarding requires admin review, this flag controls whether newly registered users can access the application. The is_demo_account field, also a <em>BOOLEAN defaulting to FALSE</em>, distinguishes between genuine user accounts and demonstration accounts created for testing or showcase purposes. Demo accounts can be programmatically cleaned up or rate-limited to prevent abuse of the system.</p>" +
                "<p>The last_activity_at field, defined as a <em>TIMESTAMP</em>, tracks the most recent user interaction with the application. This temporal data serves multiple purposes, including identifying inactive accounts for cleanup, analyzing user engagement patterns, and supporting features like \"recently active users\" displays. By maintaining this timestamp, we can implement sophisticated retention strategies and understand user behavior over time.</p>" +
                "<p>Transitioning to the <strong>notes table</strong>, we encounter a different set of design considerations focused on content management and ownership. The primary key uses a <em>UUID</em> type rather than an auto-incrementing integer, providing globally unique identifiers that are ideal for distributed systems and preventing sequential ID enumeration attacks. UUIDs offer the additional benefit of being generated client-side or server-side without coordination, enabling offline-first architectures where notes can be created without immediate server communication.</p>" +
                "<p>The title field, specified as <em>VARCHAR(500)</em>, accommodates lengthy note titles while imposing a reasonable upper bound that prevents database bloat. The generous 500-character limit ensures users can write descriptive, context-rich titles without hitting length restrictions, while the VARCHAR type optimizes storage by only consuming space for the actual content rather than padding to a fixed width. The content field utilizes the <em>TEXT</em> type, which can store up to 65,535 characters in MySQL, providing ample space for rich text content including HTML markup generated by the TipTap editor.</p>" +
                "<p>The owner_id field establishes a <em>foreign key relationship with the users table</em>, implementing a many-to-one relationship where each note belongs to exactly one user, but each user can own multiple notes. This field is defined as <em>BIGINT REFERENCES users(id)</em>, creating a referential integrity constraint that prevents orphaned notes and ensures data consistency. When a user is deleted, the database can enforce cascading deletes or prevent deletion if notes exist, depending on the configured foreign key behavior.</p>" +
                "<p>Temporal tracking in the notes table relies on two timestamp fields: created_at and updated_at. Both are defined as <em>TIMESTAMP with DEFAULT CURRENT_TIMESTAMP</em>, automatically capturing the exact moment when a note is first inserted into the database. The created_at field remains immutable throughout the note's lifecycle, serving as a permanent record of when the note was originally authored. The updated_at field, however, should be configured with <em>ON UPDATE CURRENT_TIMESTAMP</em> in the actual implementation, ensuring it automatically refreshes whenever the note content or title changes. This automatic timestamping eliminates the need for application-level timestamp management and provides accurate audit trails for note modifications.</p>" +
                "<p>Beyond these core tables, a comprehensive schema includes several supporting tables that enable advanced features. A <strong>tags table</strong> with fields like id, name, and color stores the available tags that can be applied to notes. The relationship between notes and tags requires a <strong>note_tags junction table</strong> implementing a many-to-many relationship, with foreign keys to both notes.id and tags.id. This normalized design allows multiple tags per note and efficient queries for finding all notes with a specific tag.</p>" +
                "<p>Similarly, the note sharing functionality necessitates a <strong>note_shared_users junction table</strong> that maps notes to the users with whom they've been shared. This table contains note_id and user_id foreign keys, along with optional fields like shared_at timestamp and permission_level enumeration to track when sharing occurred and what permissions were granted. By implementing sharing through a separate table rather than embedding user IDs in the notes table, we maintain normalized data and support efficient queries for both \"notes I've shared\" and \"notes shared with me\" use cases.</p>" +
                "<p><u>Indexing strategy</u> plays a crucial role in database performance. Beyond the primary keys, which are automatically indexed, we should create secondary indexes on frequently queried columns. An index on notes.owner_id accelerates queries that filter notes by owner, such as loading a user's dashboard. A composite index on (owner_id, updated_at) supports efficient sorting of a user's notes by modification time, a common operation in note-taking applications. The users.email field, despite having a UNIQUE constraint that creates an implicit index, benefits from explicit indexing to optimize login queries.</p>" +
                "<p>Considering <u>data migration and versioning</u>, the schema should be managed through migration tools like Flyway or Liquibase rather than manual SQL scripts. Each schema changeadding a column, creating a table, modifying a constraintshould be captured in a versioned migration file with both upgrade and downgrade paths. This approach ensures that development, staging, and production databases remain synchronized and that schema changes can be tested and rolled back if issues arise.</p>" +
                "<p>The schema also needs to account for <u>soft deletion patterns</u>. Rather than immediately removing deleted notes from the database, we might add a deleted_at TIMESTAMP field to the notes table, allowing for a \"trash bin\" feature where users can recover recently deleted notes. Soft deletion also supports compliance requirements for data retention and provides a safety net against accidental deletions. Queries would then filter out soft-deleted notes by adding WHERE deleted_at IS NULL conditions, while cleanup jobs periodically hard-delete notes that have been in the trash beyond a retention period.</p>" +
                "<p>From a <u>security perspective</u>, the schema supports row-level security through the ownership model. Application-level authorization logic can verify that the authenticated user's ID matches the owner_id before permitting read, update, or delete operations. For shared notes, authorization checks must also query the note_shared_users table to determine if the current user has been granted access. This dual-path authorization model ensures that users can only access notes they own or notes explicitly shared with them, preventing unauthorized data access.</p>" +
                "<p>In conclusion, database schema design requires balancing competing concerns: normalization versus denormalization, flexibility versus constraint enforcement, and query performance versus storage efficiency. The schema presented here provides a solid foundation for a collaborative note-taking application, with clear ownership semantics, efficient indexing, temporal tracking, and extensibility for future features. By carefully considering data types, constraints, and relationships during the design phase, we establish a robust data layer that can scale with the application's growth and evolve gracefully as requirements change over time.</p>",
                "database", "schema");

        createNote(user, "Performance Optimization Ideas",
                "<p><strong><u>Performance Optimization Strategy for NotesApp</u></strong></p>" +
                "<p><em>Compiled December 2024 | Priority ranking based on impact and effort</em></p>" +
                "<p>As our user base grows and data volumes increase, maintaining snappy performance requires proactive optimization across the entire stack. This document outlines strategic performance improvements we should implement in Q1 2025, organized by backend and frontend concerns. Each optimization is evaluated based on expected performance gain, implementation complexity, and ongoing maintenance burden.</p>" +
                "<p><strong>Database Indexing for Query Performance</strong></p>" +
                "<p>Our most impactful backend optimization is improving database indexing. Currently, the notes table lacks an index on the owner_id column, which means queries that filter notes by owner perform full table scans. This works fine with hundreds of notes, but once we have hundreds of thousands or millions of notes across all users, these scans will become prohibitively slow. Adding an index on notes.owner_id is a simple ALTER TABLE operation that will dramatically speed up the most common query in our application - fetching all notes owned by a specific user.</p>" +
                "<p>Even better than a single-column index is a composite index on owner_id and updated_at. This covers our most frequent query pattern completely: getting notes for a user, sorted by most recently updated first. With a composite index, the database can use the index not just for filtering but also for sorting, eliminating a costly sort operation. The index should be defined with owner_id first, then updated_at, to support both queries that filter by owner alone and queries that filter by owner and sort by updated_at.</p>" +
                "<p>Beyond these critical indexes, we should analyze slow query logs to identify other opportunities. The users table probably doesn't need additional indexes beyond the unique index on email that we already have. The tags table is small enough that additional indexes are unlikely to provide measurable benefit. The note_tags junction table should have indexes on both note_id and tag_id to support bidirectional lookups - finding tags for a note and finding notes for a tag.</p>" +
                "<p><strong>Caching Strategy with Redis</strong></p>" +
                "<p>Implementing a Redis caching layer will reduce database load and improve response times for frequently accessed data. User sessions are an ideal caching candidate because they're accessed on every authenticated request but change infrequently. Currently, we store session tokens in JWTs which are stateless and don't require database lookups, but for more complex session data or to support session invalidation, Redis provides a fast in-memory store that can handle thousands of lookups per second.</p>" +
                "<p>Note caching is more nuanced because notes change frequently. A read-through cache where we check Redis before hitting the database makes sense for notes that are viewed often but rarely edited. We can cache note metadata - title, owner, tags, timestamps - separately from content, since metadata is accessed more frequently for list views. Cache entries should have reasonable TTL values, perhaps five minutes for metadata and one minute for content, to balance staleness against cache effectiveness.</p>" +
                "<p>The caching strategy should include cache invalidation logic. When a note is updated, we need to clear its cache entry to prevent serving stale data. This requires coordination between the application layer and cache layer. A simple approach is setting short TTLs and accepting occasional staleness. A more sophisticated approach uses pub-sub messaging where note updates trigger cache invalidation events that propagate to all application servers.</p>" +
                "<p><strong>Query Optimization and Pagination</strong></p>" +
                "<p>Loading all of a user's notes in a single query is inefficient once users accumulate large note collections. Implementing cursor-based pagination where we load notes in batches of twenty or fifty dramatically reduces initial page load time and memory usage. The first page loads quickly, and subsequent pages load on demand as users scroll or navigate. This is standard practice for any application dealing with unbounded lists.</p>" +
                "<p>Lazy loading note content is another quick win. When fetching notes for a list view, we only need titles, tags, and timestamps - not the full HTML content which can be kilobytes per note. Modifying the query to SELECT title, owner_id, created_at, updated_at FROM notes rather than SELECT * reduces network transfer and database I/O. Content loads separately when a user opens a note for reading or editing, which happens less frequently than viewing the note list.</p>" +
                "<p>Search queries need special attention because they're inherently expensive. Full-text search scanning all note content is slow with large datasets. MySQL's full-text search capabilities can help, or we could use a dedicated search engine like Elasticsearch. For our current scale, adding a full-text index on notes.content and using MATCH AGAINST syntax provides good performance. As we scale further, migrating search to Elasticsearch gives us better relevance ranking and more sophisticated query capabilities.</p>" +
                "<p><strong>Frontend Code Splitting</strong></p>" +
                "<p>Our React application currently bundles all code into a single JavaScript file that users download on first page load. This works fine initially, but as we add features, the bundle grows and page load time increases. Code splitting with React.lazy allows us to break the application into smaller chunks that load on demand. The login page doesn't need editor code, and the editor doesn't need admin dashboard code. Splitting these into separate bundles reduces initial load time significantly.</p>" +
                "<p>Route-based splitting is the easiest implementation. Each major route - dashboard, editor, settings, admin - loads its own chunk. React.lazy and Suspense make this straightforward to implement. We wrap route components in lazy calls and add Suspense boundaries with loading indicators. The first time a user navigates to a route, its chunk downloads; subsequent navigations use the cached chunk. This is transparent to users except for a brief loading indicator on first route access.</p>" +
                "<p>Component-based splitting for heavy components like the rich text editor makes sense too. TipTap and its extensions are substantial dependencies that aren't needed until a user actually opens a note for editing. Lazy loading the editor component and its dependencies shaves hundreds of kilobytes off the initial bundle. Users navigating straight to the note list don't pay the cost of downloading editor code they're not using.</p>" +
                "<p><strong>Debouncing Autosave Operations</strong></p>" +
                "<p>Our current autosave debounce is two seconds, meaning changes are saved two seconds after the user stops typing. This is a reasonable default but could be optimized. For users on slow connections, two seconds might be too aggressive, generating lots of network requests. For users on fast connections working with small notes, two seconds might feel sluggish if they're quickly navigating between notes.</p>" +
                "<p>Adaptive debouncing based on network conditions and note size could optimize for both cases. If a note is small and the connection is fast, save after one second. If the note is large or the connection is slow, wait three or four seconds. We can measure network speed using the Network Information API where available. Note size is trivial to check - just look at content length. This adaptive approach provides responsive saves when possible while avoiding overwhelming slow connections.</p>" +
                "<p>Beyond debouncing, batching multiple simultaneous edits into single save requests reduces server load. If a user edits three notes in quick succession, instead of three separate save requests, we could batch them into one request that updates all three notes. This requires API changes to support batch updates, but the efficiency gains are substantial when users are rapidly working across multiple notes.</p>" +
                "<p><strong>Virtual Scrolling for Long Lists</strong></p>" +
                "<p>Users with hundreds of notes face performance degradation because we're rendering every note card in the DOM simultaneously. Virtual scrolling renders only the notes currently visible in the viewport plus a small buffer. As users scroll, off-screen notes are removed from the DOM and new notes entering the viewport are rendered. This keeps the DOM small and rendering fast regardless of total note count.</p>" +
                "<p>Libraries like react-window or react-virtualized handle the complex math of tracking scroll position, determining which items are visible, and rendering the appropriate subset. Integration is straightforward - wrap the note list in a virtual scroller component and specify item height. The main gotcha is that virtual scrolling requires fixed or calculable item heights, which works fine for our note cards that have consistent dimensions.</p>" +
                "<p>The performance improvement is dramatic for power users with large note collections. Instead of rendering five hundred DOM elements and suffering frame drops during scrolling, we render maybe twenty elements and scrolling is buttery smooth. The user experience is indistinguishable from rendering everything - they still see all their notes and can scroll freely - but the performance characteristics are vastly better.</p>" +
                "<p><em>Implementation roadmap: Database indexing should be our first priority since it's low-effort and high-impact. Cache implementation comes next, followed by pagination and lazy loading. Frontend optimizations can proceed in parallel. All changes should be tested with production-scale data to verify performance improvements.</em></p>",
                "performance", "optimization", "engineering");
    }

    private void createDesignerNotes(User user) {
        createNote(user, "Design System - Color Palette",
                DemoNotesContent.DESIGNER_COLOR_PALETTE,
                "design-system", "colors");

        createNote(user, "UI Mockups - Mobile Dashboard",
                DemoNotesContent.DESIGNER_UI_MOCKUPS,
                "wireframes", "mobile");

        createNote(user, "Typography Guidelines",
                DemoNotesContent.DESIGNER_TYPOGRAPHY,
                "typography", "design-system");

        createNote(user, "User Research Findings",
                DemoNotesContent.DESIGNER_USER_RESEARCH,
                "user-research", "usability");

        createNote(user, "Icon Library",
                DemoNotesContent.DESIGNER_ICON_LIBRARY,
                "icons", "design-system");
    }

    private void createWriterNotes(User user) {
        createNote(user, "Blog Post Draft: Getting Started with Notes",
                DemoNotesContent.WRITER_BLOG_POST,
                "blog-draft", "content", "seo");

        createNote(user, "Content Calendar Q1 2025",
                DemoNotesContent.WRITER_CONTENT_CALENDAR,
                "content-calendar", "planning");

        createNote(user, "SEO Keywords Research",
                DemoNotesContent.WRITER_SEO_KEYWORDS,
                "seo", "keywords");

        createNote(user, "Social Media Post Ideas",
                DemoNotesContent.WRITER_SOCIAL_MEDIA,
                "social-media", "content");

        createNote(user, "Email Newsletter Draft",
                DemoNotesContent.WRITER_EMAIL_NEWSLETTER,
                "newsletter", "email");
    }

    private void createStudentNotes(User user) {
        createNote(user, "Computer Science 101 - Lecture Notes",
                DemoNotesContent.STUDENT_LECTURE_NOTES,
                "cs101", "algorithms", "lecture");

        createNote(user, "Study Guide: Final Exam",
                DemoNotesContent.STUDENT_STUDY_GUIDE,
                "study-guide", "exam");

        createNote(user, "Project Ideas - Spring Semester",
                DemoNotesContent.STUDENT_PROJECT_IDEAS,
                "projects", "ideas");

        createNote(user, "Career Notes - Internship Prep",
                DemoNotesContent.STUDENT_CAREER_NOTES,
                "career", "internships");

        createNote(user, "Reading List - Winter Break",
                DemoNotesContent.STUDENT_READING_LIST,
                "reading", "books");
    }

    private String createCollaborationBanner(String... collaboratorNames) {
        if (collaboratorNames == null || collaboratorNames.length == 0) {
            return "";
        }

        String collaborators = String.join(", ", collaboratorNames);
        return "<div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 4px solid #4c51bf;'>" +
               "<p style='margin: 0; font-weight: 600; font-size: 1rem;'> Live Collaboration Active</p>" +
               "<p style='margin: 0.5rem 0 0 0; font-size: 0.875rem; opacity: 0.95;'>This note can be collaboratively edited in real-time with: <strong>" + collaborators + "</strong></p>" +
               "<p style='margin: 0.5rem 0 0 0; font-size: 0.75rem; opacity: 0.85;'>Changes will sync instantly across all collaborators!</p>" +
               "</div>";
    }

    private void createNote(User user, String title, String content, String... tagNames) {
        Note note = new Note();
        note.setOwner(user);
        note.setTitle(title);
        note.setContent(content);

        // Create and assign tags
        Set<Tag> tags = new HashSet<>();
        for (String tagName : tagNames) {
            Tag tag = tagRepository.findByName(tagName)
                    .orElseGet(() -> {
                        Tag newTag = new Tag();
                        newTag.setName(tagName);
                        return tagRepository.save(newTag);
                    });
            tags.add(tag);
        }
        note.setTags(tags);

        noteRepository.save(note);
    }
}
